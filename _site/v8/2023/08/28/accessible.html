<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>2019 强网杯 accessible分析 | ln3’s blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="2019 强网杯 accessible分析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="分析patch diff --git a/src/compiler/access-info.cc b/src/compiler/access-info.cc index 0744138..1df06df 100644 --- a/src/compiler/access-info.cc +++ b/src/compiler/access-info.cc @@ -370,9 +370,11 @@ PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo( // The field type was cleared by the GC, so we don&#39;t know anything // about the contents now. } +#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldRepresentationDependencyOffTheRecord(map_ref, descriptor)); +#endif if (descriptors_field_type-&gt;IsClass()) { // Remember the field map, and try to infer a useful type. Handle&lt;Map&gt; map(descriptors_field_type-&gt;AsClass(), isolate()); @@ -384,15 +386,17 @@ PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo( } // TODO(turbofan): We may want to do this only depending on the use // of the access info. +#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldTypeDependencyOffTheRecord(map_ref, descriptor)); +#endif PropertyConstness constness; if (details.IsReadOnly() &amp;&amp; !details.IsConfigurable()) { constness = PropertyConstness::kConst; } else { map_ref.SerializeOwnDescriptor(descriptor); - constness = dependencies()-&gt;DependOnFieldConstness(map_ref, descriptor); + constness = PropertyConstness::kConst; } Handle&lt;Map&gt; field_owner_map(map-&gt;FindFieldOwner(isolate(), descriptor), isolate()); patch点位于ComputeDataFieldAccessInfo中 将两个unrecord_dependencies.push的操作注释掉了，同时将PropertyConstness类型的constness将原来的DependOnFieldConstness结果改为了固定的kConst 找到该函数的源码 该函数返回了一个DataField或者DataConst，但是仅有一个kind不同 同时也注意到第一个push出现在details_representation为HeapObject的case 向上查看details_representation指代的对象是谁 从details获取details_representation，details为map的DescriptorArray中的某一项属性记录的detail receiver_map为被查找对象的map，向上寻找map变量的来源 经过一些调试会发现此时的receiver_map与map均为被访问对象的map 此循环在原型链上搜索属性，以map为循环变量，传入的map为实际的拥有属性的对象的map，所以如果仅在变量上定义属性时这里一般会相等 分析一下被去掉的代码的作用 函数产生了一个CompilationDependency一个抽象基类指针 CompilationDependency派生出很多Dependency 都实现了Install函数，对code安装依赖 根据对jit编译的了解，可以知道这些dependency是用来标明jit代码的依赖，当依赖不满足时及时地将代码deoptimize回bytecode解释器执行 在建立依赖的过程中，首先从拥有属性的map中调用FindFieldOwner 需要理解一下这个fieldowner具体是指谁的map 实现中有两种实现，在jsheapbroker的模式为disable时调用map的FindFieldOwner方法 或者是从mapref类所引用的map的instance_descriptors中找到对应索引的PropertyDescriptor 里面只有一个字段看起来是与map相关的，即field_owner 我们写一个例子来看一下 var o = {&#39;p&#39;:{&#39;q&#39;:1.1}}; %DebugPrint(o); %DebugPrint(o.p); %SystemBreak(); DebugPrint: 0x273fe544b249: [JS_OBJECT_TYPE] - map: 0x11232970a6b9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt; - elements: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - properties: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; { #p: 0x273fe544b269 &lt;Object map = 0x11232970a669&gt; (const data field 0) } 0x11232970a6b9: [Map] - type: JS_OBJECT_TYPE - instance size: 32 - inobject properties: 1 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x11232970a619 &lt;Map(HOLEY_ELEMENTS)&gt; - prototype_validity cell: 0x2a8e03680659 &lt;Cell value= 1&gt; - instance descriptors (own) #1: 0x273fe544b2b9 &lt;DescriptorArray[1]&gt; - layout descriptor: (nil) - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt; - constructor: 0x1b89284c2119 &lt;JSFunction Object (sfi = 0x2a8e036898e9)&gt; - dependent code: 0x1cf27a1c02a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0 DebugPrint: 0x273fe544b269: [JS_OBJECT_TYPE] - map: 0x11232970a669 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt; - elements: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - properties: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; { #q: &lt;unboxed double&gt; 1.1 (const data field 0) } 0x11232970a669: [Map] - type: JS_OBJECT_TYPE - instance size: 32 - inobject properties: 1 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x11232970a619 &lt;Map(HOLEY_ELEMENTS)&gt; - prototype_validity cell: 0x2a8e03680659 &lt;Cell value= 1&gt; - instance descriptors (own) #1: 0x273fe544b289 &lt;DescriptorArray[1]&gt; - layout descriptor: 0x100000000 - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt; - constructor: 0x1b89284c2119 &lt;JSFunction Object (sfi = 0x2a8e036898e9)&gt; - dependent code: 0x1cf27a1c02a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0 pwndbg&gt; job 0x273fe544b2b9 0x273fe544b2b9: [DescriptorArray] - map: 0x1cf27a1c0251 &lt;Map&gt; - enum_cache: empty - nof slack descriptors: 0 - nof descriptors: 1 - raw marked descriptors: mc epoch 0, marked 0 [0]: #p (const data field 0:h, p: 0, attrs: [WEC]) @ Class(0x11232970a669) pwndbg&gt; tel 0x273fe544b2b9-1 00:0000│ 0x273fe544b2b8 —▸ 0x1cf27a1c0251 ◂— 0x1cf27a1c01 01:0008│ 0x273fe544b2c0 ◂— 0x10001 02:0010│ 0x273fe544b2c8 —▸ 0x1cf27a1c2389 ◂— 0x100001cf27a1c23 03:0018│ 0x273fe544b2d0 —▸ 0x1b89284df859 ◂— 0x4200001cf27a1c04 04:0020│ 0x273fe544b2d8 ◂— 0xc400000000 05:0028│ 0x273fe544b2e0 —▸ 0x11232970a66b ◂— 0x4030400001cf27a # field map 06:0030│ 0x273fe544b2e8 ◂— 0xdeadbeedbeadbeef 07:0038│ 0x273fe544b2f0 ◂— 0xdeadbeedbeadbeef pwndbg&gt; job 0x1b89284df859 #p 可以观察到o对象的instace_descriptor的DescriptorArray中拥有p的map 看似此时可以得到FindFieldOwner返回的应该是字段的map的结论，但是调试过后发现并非如此 分析map的FindFieldOwner函数，理论上该函数应当与mapref中的函数返回相同结果 这里进行了一个循环，遍历对象的back pointer链来寻找一个拥有descriptor索引的instance_descriptor，并将具有这个instace_descriptor的对象作为map返回 但是我们这里的back pointer是不存在这个属性的 pwndbg&gt; job 0xe2008c0a6b9 0xe2008c0a6b9: [Map] - type: JS_OBJECT_TYPE - instance size: 32 - inobject properties: 1 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x0e2008c0a619 &lt;Map(HOLEY_ELEMENTS)&gt; # back pointer链 - prototype_validity cell: 0x0d2e9b9c0659 &lt;Cell value= 1&gt; - instance descriptors (own) #1: 0x31de10fcb5c1 &lt;DescriptorArray[1]&gt; # 长度 == 1, 需要找到一个有0索引的对象 - layout descriptor: (nil) - prototype: 0x24c1d11820e1 &lt;Object map = 0xe2008c00209&gt; - constructor: 0x24c1d1182119 &lt;JSFunction Object (sfi = 0xd2e9b9c98e9)&gt; - dependent code: 0x02f667c402a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0 pwndbg&gt; job 0x0e2008c0a619 0xe2008c0a619: [Map] - type: JS_OBJECT_TYPE - instance size: 32 - inobject properties: 1 - elements kind: HOLEY_ELEMENTS - unused property fields: 1 - enum length: invalid - back pointer: 0x02f667c404b1 &lt;undefined&gt; # 链尾 - prototype_validity cell: 0x0d2e9b9c0659 &lt;Cell value= 1&gt; - instance descriptors (own) #0: 0x02f667c40239 &lt;DescriptorArray[0]&gt; # 长度 == 0 - layout descriptor: (nil) - transitions #2: 0x24c1d119fe11 &lt;TransitionArray[6]&gt;Transition array #2: #a: (transition to (const data field, attrs: [WEC]) @ Class(0xe2008c0a669)) -&gt; 0x0e2008c0a6b9 &lt;Map(HOLEY_ELEMENTS)&gt; #m: (transition to (const data field, attrs: [WEC]) @ Any) -&gt; 0x0e2008c0a669 &lt;Map(HOLEY_ELEMENTS)&gt; - prototype: 0x24c1d11820e1 &lt;Object map = 0xe2008c00209&gt; - constructor: 0x24c1d1182119 &lt;JSFunction Object (sfi = 0xd2e9b9c98e9)&gt; - dependent code: 0x02f667c402a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0 所以这个函数最后返回的依然是本对象的map，而不是先前推测的字段属性的map， 而关于之前DescriptorArray中的map的来源，从chromium code search里DescriptorArray的注释中提到结构中的value可能会有一个map的weak reference，但是并没有解释其作用与具体指向 我们可以以此推测jsheapbroker实际上会对js对象的一些数据做cache，将对象的字段的owner记录在PropertyDescriptor结构中，这样就省去了每次遍历back pointer的开销 查找一下引用会发现在SerializeOwnDescriptor中，存在对PropertyDescriptor的创建 简要分析可以发现该函数透过jsheapbroker更新了map的instance_descriptor中对应属性的PropertyDescriptor信息，验证了我们刚才的推测 回到函数，可以确认此时owner为拥有此属性的对象的map InstallDependency的逻辑较为简单，更新将code插入map的dependent code字段数组中 我们看到PropertyAccessBuilder的BuildCheckMaps函数的逻辑 可以看到这里有两种方式，第一种判断了receiver的map是否stable，如果stable，且根据access_info得到的receiver_maps中确实有这个map，则添加一个StableMap的依赖 否则创建一个checkmaps的node，在运行时鉴别对象的map 这里也说明了v8中有两种deoptimize的机制，一种是通过依赖来标记代码，在运行时若发生了依赖变化，则deoptimize相应代码，另一种则是使用checkmaps的代码来运行时检查map类型是否匹配 map的dependent code就是为了deoptimize而设，当map变为unstable时，即可根据该字段来遍历所有依赖当前stable map的optimized code 所有依赖在Commit函数中被Install，时机为编译流水线的结尾 此时审视我们最开始得到的patch +#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldRepresentationDependencyOffTheRecord(map_ref, descriptor)); +#endif if (descriptors_field_type-&gt;IsClass()) { // Remember the field map, and try to infer a useful type. Handle&lt;Map&gt; map(descriptors_field_type-&gt;AsClass(), isolate()); @@ -384,15 +386,17 @@ PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo( } // TODO(turbofan): We may want to do this only depending on the use // of the access info. +#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldTypeDependencyOffTheRecord(map_ref, descriptor)); +#endif FieldType根据一些代码可以知道实际就是指代字段的map 这里将两个依赖注释了，导致当字段属性的representation为HeapObject时，程序没有正确地记录FieldOwner对于field的representation与type的依赖，而记录是通过对map install dependent code来完成的，因此在函数编译后，修改FieldOwner类型理论上也不会 所以理论上可以修改FieldOwner的类型来造成类型混淆 我们还需要确定一下函数的触发路径 在chromium code search中查找一下patch函数引用 只出现在ComputePropertyAccessInfo中，继续往下找 有两个引用 分别查看一下 GetPropertyAccessInfo用的更加频繁一些，同时注意到有一个ReduceNamedAccess，这表明turbofan在优化具名属性访问如o.xxx时会引用到这里的结果 剖析poc function opt(o) { return o.x.y; } let obj = {x: {y: 1.1}} for (let i = 0; i &lt; 100000; i++) opt(obj); obj.x = {z: {}}; console.log(opt(obj)) 观察生成的字节码 opt函数产生了两次属性访问 通过以下命令进行调试 gdb --args ./d8 --allow-natives-syntax --trace-opt-verbose --trace-deopt ./poc.js 通过turbolizer观察编译过程中的节点变化 发现产生了两个checkmaps，与我们预期的通过depend code进行deoptimize有些不符 且在loadelimination阶段将第二个checkmaps去除 分析checkmaps的出处 当receiver转换为string或number失败时调用BuildCheckMaps 调试发现m.HasValue()对于两次调用均不成立 发现此函数需要node的opcode为HeapConstant，难以满足，所以落入checkmaps的path 通过调试也发现dependent code集中在o.x而非o 分析loadelimination中发生的事 调用ReduceCheckMaps，第一次调用时，node state中没有记录map，通过该checkmaps后更新check的map范围到node state中 再经过ReduceLoadField获取到field的map，更新到node state中，故第二次时map会落入范围中，成功reduce poc中最后使用了重赋值来修改obj.x的类型，这个操作并不会改变obj的map 同时也注意到obj的初始化方式较为特别 let obj = {x: {y: 1.1}} v8中初始化对象时，若采取以下形式 let a = {b:1,c:2,d:3,e:4,f:5} 则v8会尽量优化成a对象中带有5个inline property，直接依附在对象结构上，而不在Properties数组中 同时一个字典默认初始化时，一般会带有4个默认的slot来存放property let a = {} a.x0 = 0; // inline a.x1 = 1; // inline a.x2 = 2; // inline a.x3 = 3; // inline a.x4 = 4; // in properties 具体可以参考v8 blogs中的这篇文章 同时触发混淆的成员名不能与原来相同 let obj = {x: {y: 1.1}} for (let i = 0; i &lt; 100000; i++) opt(obj); obj.x = {z: {}}; console.log(opt(obj)) 即此处的z不能为y 因为这样创造出来的{y:{}}实际是{y:1.1}的泛化 由于v8的field representation generalization机制，当一个field被修改成一个更加泛用的类型的值时，如smi修改为Tagged指针，为了表示这样的转变，v8根据版本不同会有两种处理方式，较早的版本会建立一个新map，将field representation修改为Tagged，将原来的map舍弃，较新的版本考虑到性能问题，会就地进行可兼容的representation转换，但是这两种方法最终都会invalidate code dependency，导致deoptimize 这个逻辑实现在Map::GeneralizeField中" />
<meta property="og:description" content="分析patch diff --git a/src/compiler/access-info.cc b/src/compiler/access-info.cc index 0744138..1df06df 100644 --- a/src/compiler/access-info.cc +++ b/src/compiler/access-info.cc @@ -370,9 +370,11 @@ PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo( // The field type was cleared by the GC, so we don&#39;t know anything // about the contents now. } +#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldRepresentationDependencyOffTheRecord(map_ref, descriptor)); +#endif if (descriptors_field_type-&gt;IsClass()) { // Remember the field map, and try to infer a useful type. Handle&lt;Map&gt; map(descriptors_field_type-&gt;AsClass(), isolate()); @@ -384,15 +386,17 @@ PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo( } // TODO(turbofan): We may want to do this only depending on the use // of the access info. +#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldTypeDependencyOffTheRecord(map_ref, descriptor)); +#endif PropertyConstness constness; if (details.IsReadOnly() &amp;&amp; !details.IsConfigurable()) { constness = PropertyConstness::kConst; } else { map_ref.SerializeOwnDescriptor(descriptor); - constness = dependencies()-&gt;DependOnFieldConstness(map_ref, descriptor); + constness = PropertyConstness::kConst; } Handle&lt;Map&gt; field_owner_map(map-&gt;FindFieldOwner(isolate(), descriptor), isolate()); patch点位于ComputeDataFieldAccessInfo中 将两个unrecord_dependencies.push的操作注释掉了，同时将PropertyConstness类型的constness将原来的DependOnFieldConstness结果改为了固定的kConst 找到该函数的源码 该函数返回了一个DataField或者DataConst，但是仅有一个kind不同 同时也注意到第一个push出现在details_representation为HeapObject的case 向上查看details_representation指代的对象是谁 从details获取details_representation，details为map的DescriptorArray中的某一项属性记录的detail receiver_map为被查找对象的map，向上寻找map变量的来源 经过一些调试会发现此时的receiver_map与map均为被访问对象的map 此循环在原型链上搜索属性，以map为循环变量，传入的map为实际的拥有属性的对象的map，所以如果仅在变量上定义属性时这里一般会相等 分析一下被去掉的代码的作用 函数产生了一个CompilationDependency一个抽象基类指针 CompilationDependency派生出很多Dependency 都实现了Install函数，对code安装依赖 根据对jit编译的了解，可以知道这些dependency是用来标明jit代码的依赖，当依赖不满足时及时地将代码deoptimize回bytecode解释器执行 在建立依赖的过程中，首先从拥有属性的map中调用FindFieldOwner 需要理解一下这个fieldowner具体是指谁的map 实现中有两种实现，在jsheapbroker的模式为disable时调用map的FindFieldOwner方法 或者是从mapref类所引用的map的instance_descriptors中找到对应索引的PropertyDescriptor 里面只有一个字段看起来是与map相关的，即field_owner 我们写一个例子来看一下 var o = {&#39;p&#39;:{&#39;q&#39;:1.1}}; %DebugPrint(o); %DebugPrint(o.p); %SystemBreak(); DebugPrint: 0x273fe544b249: [JS_OBJECT_TYPE] - map: 0x11232970a6b9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt; - elements: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - properties: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; { #p: 0x273fe544b269 &lt;Object map = 0x11232970a669&gt; (const data field 0) } 0x11232970a6b9: [Map] - type: JS_OBJECT_TYPE - instance size: 32 - inobject properties: 1 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x11232970a619 &lt;Map(HOLEY_ELEMENTS)&gt; - prototype_validity cell: 0x2a8e03680659 &lt;Cell value= 1&gt; - instance descriptors (own) #1: 0x273fe544b2b9 &lt;DescriptorArray[1]&gt; - layout descriptor: (nil) - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt; - constructor: 0x1b89284c2119 &lt;JSFunction Object (sfi = 0x2a8e036898e9)&gt; - dependent code: 0x1cf27a1c02a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0 DebugPrint: 0x273fe544b269: [JS_OBJECT_TYPE] - map: 0x11232970a669 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt; - elements: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - properties: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; { #q: &lt;unboxed double&gt; 1.1 (const data field 0) } 0x11232970a669: [Map] - type: JS_OBJECT_TYPE - instance size: 32 - inobject properties: 1 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x11232970a619 &lt;Map(HOLEY_ELEMENTS)&gt; - prototype_validity cell: 0x2a8e03680659 &lt;Cell value= 1&gt; - instance descriptors (own) #1: 0x273fe544b289 &lt;DescriptorArray[1]&gt; - layout descriptor: 0x100000000 - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt; - constructor: 0x1b89284c2119 &lt;JSFunction Object (sfi = 0x2a8e036898e9)&gt; - dependent code: 0x1cf27a1c02a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0 pwndbg&gt; job 0x273fe544b2b9 0x273fe544b2b9: [DescriptorArray] - map: 0x1cf27a1c0251 &lt;Map&gt; - enum_cache: empty - nof slack descriptors: 0 - nof descriptors: 1 - raw marked descriptors: mc epoch 0, marked 0 [0]: #p (const data field 0:h, p: 0, attrs: [WEC]) @ Class(0x11232970a669) pwndbg&gt; tel 0x273fe544b2b9-1 00:0000│ 0x273fe544b2b8 —▸ 0x1cf27a1c0251 ◂— 0x1cf27a1c01 01:0008│ 0x273fe544b2c0 ◂— 0x10001 02:0010│ 0x273fe544b2c8 —▸ 0x1cf27a1c2389 ◂— 0x100001cf27a1c23 03:0018│ 0x273fe544b2d0 —▸ 0x1b89284df859 ◂— 0x4200001cf27a1c04 04:0020│ 0x273fe544b2d8 ◂— 0xc400000000 05:0028│ 0x273fe544b2e0 —▸ 0x11232970a66b ◂— 0x4030400001cf27a # field map 06:0030│ 0x273fe544b2e8 ◂— 0xdeadbeedbeadbeef 07:0038│ 0x273fe544b2f0 ◂— 0xdeadbeedbeadbeef pwndbg&gt; job 0x1b89284df859 #p 可以观察到o对象的instace_descriptor的DescriptorArray中拥有p的map 看似此时可以得到FindFieldOwner返回的应该是字段的map的结论，但是调试过后发现并非如此 分析map的FindFieldOwner函数，理论上该函数应当与mapref中的函数返回相同结果 这里进行了一个循环，遍历对象的back pointer链来寻找一个拥有descriptor索引的instance_descriptor，并将具有这个instace_descriptor的对象作为map返回 但是我们这里的back pointer是不存在这个属性的 pwndbg&gt; job 0xe2008c0a6b9 0xe2008c0a6b9: [Map] - type: JS_OBJECT_TYPE - instance size: 32 - inobject properties: 1 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x0e2008c0a619 &lt;Map(HOLEY_ELEMENTS)&gt; # back pointer链 - prototype_validity cell: 0x0d2e9b9c0659 &lt;Cell value= 1&gt; - instance descriptors (own) #1: 0x31de10fcb5c1 &lt;DescriptorArray[1]&gt; # 长度 == 1, 需要找到一个有0索引的对象 - layout descriptor: (nil) - prototype: 0x24c1d11820e1 &lt;Object map = 0xe2008c00209&gt; - constructor: 0x24c1d1182119 &lt;JSFunction Object (sfi = 0xd2e9b9c98e9)&gt; - dependent code: 0x02f667c402a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0 pwndbg&gt; job 0x0e2008c0a619 0xe2008c0a619: [Map] - type: JS_OBJECT_TYPE - instance size: 32 - inobject properties: 1 - elements kind: HOLEY_ELEMENTS - unused property fields: 1 - enum length: invalid - back pointer: 0x02f667c404b1 &lt;undefined&gt; # 链尾 - prototype_validity cell: 0x0d2e9b9c0659 &lt;Cell value= 1&gt; - instance descriptors (own) #0: 0x02f667c40239 &lt;DescriptorArray[0]&gt; # 长度 == 0 - layout descriptor: (nil) - transitions #2: 0x24c1d119fe11 &lt;TransitionArray[6]&gt;Transition array #2: #a: (transition to (const data field, attrs: [WEC]) @ Class(0xe2008c0a669)) -&gt; 0x0e2008c0a6b9 &lt;Map(HOLEY_ELEMENTS)&gt; #m: (transition to (const data field, attrs: [WEC]) @ Any) -&gt; 0x0e2008c0a669 &lt;Map(HOLEY_ELEMENTS)&gt; - prototype: 0x24c1d11820e1 &lt;Object map = 0xe2008c00209&gt; - constructor: 0x24c1d1182119 &lt;JSFunction Object (sfi = 0xd2e9b9c98e9)&gt; - dependent code: 0x02f667c402a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0 所以这个函数最后返回的依然是本对象的map，而不是先前推测的字段属性的map， 而关于之前DescriptorArray中的map的来源，从chromium code search里DescriptorArray的注释中提到结构中的value可能会有一个map的weak reference，但是并没有解释其作用与具体指向 我们可以以此推测jsheapbroker实际上会对js对象的一些数据做cache，将对象的字段的owner记录在PropertyDescriptor结构中，这样就省去了每次遍历back pointer的开销 查找一下引用会发现在SerializeOwnDescriptor中，存在对PropertyDescriptor的创建 简要分析可以发现该函数透过jsheapbroker更新了map的instance_descriptor中对应属性的PropertyDescriptor信息，验证了我们刚才的推测 回到函数，可以确认此时owner为拥有此属性的对象的map InstallDependency的逻辑较为简单，更新将code插入map的dependent code字段数组中 我们看到PropertyAccessBuilder的BuildCheckMaps函数的逻辑 可以看到这里有两种方式，第一种判断了receiver的map是否stable，如果stable，且根据access_info得到的receiver_maps中确实有这个map，则添加一个StableMap的依赖 否则创建一个checkmaps的node，在运行时鉴别对象的map 这里也说明了v8中有两种deoptimize的机制，一种是通过依赖来标记代码，在运行时若发生了依赖变化，则deoptimize相应代码，另一种则是使用checkmaps的代码来运行时检查map类型是否匹配 map的dependent code就是为了deoptimize而设，当map变为unstable时，即可根据该字段来遍历所有依赖当前stable map的optimized code 所有依赖在Commit函数中被Install，时机为编译流水线的结尾 此时审视我们最开始得到的patch +#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldRepresentationDependencyOffTheRecord(map_ref, descriptor)); +#endif if (descriptors_field_type-&gt;IsClass()) { // Remember the field map, and try to infer a useful type. Handle&lt;Map&gt; map(descriptors_field_type-&gt;AsClass(), isolate()); @@ -384,15 +386,17 @@ PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo( } // TODO(turbofan): We may want to do this only depending on the use // of the access info. +#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldTypeDependencyOffTheRecord(map_ref, descriptor)); +#endif FieldType根据一些代码可以知道实际就是指代字段的map 这里将两个依赖注释了，导致当字段属性的representation为HeapObject时，程序没有正确地记录FieldOwner对于field的representation与type的依赖，而记录是通过对map install dependent code来完成的，因此在函数编译后，修改FieldOwner类型理论上也不会 所以理论上可以修改FieldOwner的类型来造成类型混淆 我们还需要确定一下函数的触发路径 在chromium code search中查找一下patch函数引用 只出现在ComputePropertyAccessInfo中，继续往下找 有两个引用 分别查看一下 GetPropertyAccessInfo用的更加频繁一些，同时注意到有一个ReduceNamedAccess，这表明turbofan在优化具名属性访问如o.xxx时会引用到这里的结果 剖析poc function opt(o) { return o.x.y; } let obj = {x: {y: 1.1}} for (let i = 0; i &lt; 100000; i++) opt(obj); obj.x = {z: {}}; console.log(opt(obj)) 观察生成的字节码 opt函数产生了两次属性访问 通过以下命令进行调试 gdb --args ./d8 --allow-natives-syntax --trace-opt-verbose --trace-deopt ./poc.js 通过turbolizer观察编译过程中的节点变化 发现产生了两个checkmaps，与我们预期的通过depend code进行deoptimize有些不符 且在loadelimination阶段将第二个checkmaps去除 分析checkmaps的出处 当receiver转换为string或number失败时调用BuildCheckMaps 调试发现m.HasValue()对于两次调用均不成立 发现此函数需要node的opcode为HeapConstant，难以满足，所以落入checkmaps的path 通过调试也发现dependent code集中在o.x而非o 分析loadelimination中发生的事 调用ReduceCheckMaps，第一次调用时，node state中没有记录map，通过该checkmaps后更新check的map范围到node state中 再经过ReduceLoadField获取到field的map，更新到node state中，故第二次时map会落入范围中，成功reduce poc中最后使用了重赋值来修改obj.x的类型，这个操作并不会改变obj的map 同时也注意到obj的初始化方式较为特别 let obj = {x: {y: 1.1}} v8中初始化对象时，若采取以下形式 let a = {b:1,c:2,d:3,e:4,f:5} 则v8会尽量优化成a对象中带有5个inline property，直接依附在对象结构上，而不在Properties数组中 同时一个字典默认初始化时，一般会带有4个默认的slot来存放property let a = {} a.x0 = 0; // inline a.x1 = 1; // inline a.x2 = 2; // inline a.x3 = 3; // inline a.x4 = 4; // in properties 具体可以参考v8 blogs中的这篇文章 同时触发混淆的成员名不能与原来相同 let obj = {x: {y: 1.1}} for (let i = 0; i &lt; 100000; i++) opt(obj); obj.x = {z: {}}; console.log(opt(obj)) 即此处的z不能为y 因为这样创造出来的{y:{}}实际是{y:1.1}的泛化 由于v8的field representation generalization机制，当一个field被修改成一个更加泛用的类型的值时，如smi修改为Tagged指针，为了表示这样的转变，v8根据版本不同会有两种处理方式，较早的版本会建立一个新map，将field representation修改为Tagged，将原来的map舍弃，较新的版本考虑到性能问题，会就地进行可兼容的representation转换，但是这两种方法最终都会invalidate code dependency，导致deoptimize 这个逻辑实现在Map::GeneralizeField中" />
<link rel="canonical" href="http://localhost:4000/v8/2023/08/28/accessible.html" />
<meta property="og:url" content="http://localhost:4000/v8/2023/08/28/accessible.html" />
<meta property="og:site_name" content="ln3’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-08-28T07:20:22+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="2019 强网杯 accessible分析" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-08-28T07:20:22+08:00","datePublished":"2023-08-28T07:20:22+08:00","description":"分析patch diff --git a/src/compiler/access-info.cc b/src/compiler/access-info.cc index 0744138..1df06df 100644 --- a/src/compiler/access-info.cc +++ b/src/compiler/access-info.cc @@ -370,9 +370,11 @@ PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo( // The field type was cleared by the GC, so we don&#39;t know anything // about the contents now. } +#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldRepresentationDependencyOffTheRecord(map_ref, descriptor)); +#endif if (descriptors_field_type-&gt;IsClass()) { // Remember the field map, and try to infer a useful type. Handle&lt;Map&gt; map(descriptors_field_type-&gt;AsClass(), isolate()); @@ -384,15 +386,17 @@ PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo( } // TODO(turbofan): We may want to do this only depending on the use // of the access info. +#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldTypeDependencyOffTheRecord(map_ref, descriptor)); +#endif PropertyConstness constness; if (details.IsReadOnly() &amp;&amp; !details.IsConfigurable()) { constness = PropertyConstness::kConst; } else { map_ref.SerializeOwnDescriptor(descriptor); - constness = dependencies()-&gt;DependOnFieldConstness(map_ref, descriptor); + constness = PropertyConstness::kConst; } Handle&lt;Map&gt; field_owner_map(map-&gt;FindFieldOwner(isolate(), descriptor), isolate()); patch点位于ComputeDataFieldAccessInfo中 将两个unrecord_dependencies.push的操作注释掉了，同时将PropertyConstness类型的constness将原来的DependOnFieldConstness结果改为了固定的kConst 找到该函数的源码 该函数返回了一个DataField或者DataConst，但是仅有一个kind不同 同时也注意到第一个push出现在details_representation为HeapObject的case 向上查看details_representation指代的对象是谁 从details获取details_representation，details为map的DescriptorArray中的某一项属性记录的detail receiver_map为被查找对象的map，向上寻找map变量的来源 经过一些调试会发现此时的receiver_map与map均为被访问对象的map 此循环在原型链上搜索属性，以map为循环变量，传入的map为实际的拥有属性的对象的map，所以如果仅在变量上定义属性时这里一般会相等 分析一下被去掉的代码的作用 函数产生了一个CompilationDependency一个抽象基类指针 CompilationDependency派生出很多Dependency 都实现了Install函数，对code安装依赖 根据对jit编译的了解，可以知道这些dependency是用来标明jit代码的依赖，当依赖不满足时及时地将代码deoptimize回bytecode解释器执行 在建立依赖的过程中，首先从拥有属性的map中调用FindFieldOwner 需要理解一下这个fieldowner具体是指谁的map 实现中有两种实现，在jsheapbroker的模式为disable时调用map的FindFieldOwner方法 或者是从mapref类所引用的map的instance_descriptors中找到对应索引的PropertyDescriptor 里面只有一个字段看起来是与map相关的，即field_owner 我们写一个例子来看一下 var o = {&#39;p&#39;:{&#39;q&#39;:1.1}}; %DebugPrint(o); %DebugPrint(o.p); %SystemBreak(); DebugPrint: 0x273fe544b249: [JS_OBJECT_TYPE] - map: 0x11232970a6b9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt; - elements: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - properties: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; { #p: 0x273fe544b269 &lt;Object map = 0x11232970a669&gt; (const data field 0) } 0x11232970a6b9: [Map] - type: JS_OBJECT_TYPE - instance size: 32 - inobject properties: 1 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x11232970a619 &lt;Map(HOLEY_ELEMENTS)&gt; - prototype_validity cell: 0x2a8e03680659 &lt;Cell value= 1&gt; - instance descriptors (own) #1: 0x273fe544b2b9 &lt;DescriptorArray[1]&gt; - layout descriptor: (nil) - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt; - constructor: 0x1b89284c2119 &lt;JSFunction Object (sfi = 0x2a8e036898e9)&gt; - dependent code: 0x1cf27a1c02a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0 DebugPrint: 0x273fe544b269: [JS_OBJECT_TYPE] - map: 0x11232970a669 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt; - elements: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - properties: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; { #q: &lt;unboxed double&gt; 1.1 (const data field 0) } 0x11232970a669: [Map] - type: JS_OBJECT_TYPE - instance size: 32 - inobject properties: 1 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x11232970a619 &lt;Map(HOLEY_ELEMENTS)&gt; - prototype_validity cell: 0x2a8e03680659 &lt;Cell value= 1&gt; - instance descriptors (own) #1: 0x273fe544b289 &lt;DescriptorArray[1]&gt; - layout descriptor: 0x100000000 - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt; - constructor: 0x1b89284c2119 &lt;JSFunction Object (sfi = 0x2a8e036898e9)&gt; - dependent code: 0x1cf27a1c02a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0 pwndbg&gt; job 0x273fe544b2b9 0x273fe544b2b9: [DescriptorArray] - map: 0x1cf27a1c0251 &lt;Map&gt; - enum_cache: empty - nof slack descriptors: 0 - nof descriptors: 1 - raw marked descriptors: mc epoch 0, marked 0 [0]: #p (const data field 0:h, p: 0, attrs: [WEC]) @ Class(0x11232970a669) pwndbg&gt; tel 0x273fe544b2b9-1 00:0000│ 0x273fe544b2b8 —▸ 0x1cf27a1c0251 ◂— 0x1cf27a1c01 01:0008│ 0x273fe544b2c0 ◂— 0x10001 02:0010│ 0x273fe544b2c8 —▸ 0x1cf27a1c2389 ◂— 0x100001cf27a1c23 03:0018│ 0x273fe544b2d0 —▸ 0x1b89284df859 ◂— 0x4200001cf27a1c04 04:0020│ 0x273fe544b2d8 ◂— 0xc400000000 05:0028│ 0x273fe544b2e0 —▸ 0x11232970a66b ◂— 0x4030400001cf27a # field map 06:0030│ 0x273fe544b2e8 ◂— 0xdeadbeedbeadbeef 07:0038│ 0x273fe544b2f0 ◂— 0xdeadbeedbeadbeef pwndbg&gt; job 0x1b89284df859 #p 可以观察到o对象的instace_descriptor的DescriptorArray中拥有p的map 看似此时可以得到FindFieldOwner返回的应该是字段的map的结论，但是调试过后发现并非如此 分析map的FindFieldOwner函数，理论上该函数应当与mapref中的函数返回相同结果 这里进行了一个循环，遍历对象的back pointer链来寻找一个拥有descriptor索引的instance_descriptor，并将具有这个instace_descriptor的对象作为map返回 但是我们这里的back pointer是不存在这个属性的 pwndbg&gt; job 0xe2008c0a6b9 0xe2008c0a6b9: [Map] - type: JS_OBJECT_TYPE - instance size: 32 - inobject properties: 1 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x0e2008c0a619 &lt;Map(HOLEY_ELEMENTS)&gt; # back pointer链 - prototype_validity cell: 0x0d2e9b9c0659 &lt;Cell value= 1&gt; - instance descriptors (own) #1: 0x31de10fcb5c1 &lt;DescriptorArray[1]&gt; # 长度 == 1, 需要找到一个有0索引的对象 - layout descriptor: (nil) - prototype: 0x24c1d11820e1 &lt;Object map = 0xe2008c00209&gt; - constructor: 0x24c1d1182119 &lt;JSFunction Object (sfi = 0xd2e9b9c98e9)&gt; - dependent code: 0x02f667c402a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0 pwndbg&gt; job 0x0e2008c0a619 0xe2008c0a619: [Map] - type: JS_OBJECT_TYPE - instance size: 32 - inobject properties: 1 - elements kind: HOLEY_ELEMENTS - unused property fields: 1 - enum length: invalid - back pointer: 0x02f667c404b1 &lt;undefined&gt; # 链尾 - prototype_validity cell: 0x0d2e9b9c0659 &lt;Cell value= 1&gt; - instance descriptors (own) #0: 0x02f667c40239 &lt;DescriptorArray[0]&gt; # 长度 == 0 - layout descriptor: (nil) - transitions #2: 0x24c1d119fe11 &lt;TransitionArray[6]&gt;Transition array #2: #a: (transition to (const data field, attrs: [WEC]) @ Class(0xe2008c0a669)) -&gt; 0x0e2008c0a6b9 &lt;Map(HOLEY_ELEMENTS)&gt; #m: (transition to (const data field, attrs: [WEC]) @ Any) -&gt; 0x0e2008c0a669 &lt;Map(HOLEY_ELEMENTS)&gt; - prototype: 0x24c1d11820e1 &lt;Object map = 0xe2008c00209&gt; - constructor: 0x24c1d1182119 &lt;JSFunction Object (sfi = 0xd2e9b9c98e9)&gt; - dependent code: 0x02f667c402a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0 所以这个函数最后返回的依然是本对象的map，而不是先前推测的字段属性的map， 而关于之前DescriptorArray中的map的来源，从chromium code search里DescriptorArray的注释中提到结构中的value可能会有一个map的weak reference，但是并没有解释其作用与具体指向 我们可以以此推测jsheapbroker实际上会对js对象的一些数据做cache，将对象的字段的owner记录在PropertyDescriptor结构中，这样就省去了每次遍历back pointer的开销 查找一下引用会发现在SerializeOwnDescriptor中，存在对PropertyDescriptor的创建 简要分析可以发现该函数透过jsheapbroker更新了map的instance_descriptor中对应属性的PropertyDescriptor信息，验证了我们刚才的推测 回到函数，可以确认此时owner为拥有此属性的对象的map InstallDependency的逻辑较为简单，更新将code插入map的dependent code字段数组中 我们看到PropertyAccessBuilder的BuildCheckMaps函数的逻辑 可以看到这里有两种方式，第一种判断了receiver的map是否stable，如果stable，且根据access_info得到的receiver_maps中确实有这个map，则添加一个StableMap的依赖 否则创建一个checkmaps的node，在运行时鉴别对象的map 这里也说明了v8中有两种deoptimize的机制，一种是通过依赖来标记代码，在运行时若发生了依赖变化，则deoptimize相应代码，另一种则是使用checkmaps的代码来运行时检查map类型是否匹配 map的dependent code就是为了deoptimize而设，当map变为unstable时，即可根据该字段来遍历所有依赖当前stable map的optimized code 所有依赖在Commit函数中被Install，时机为编译流水线的结尾 此时审视我们最开始得到的patch +#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldRepresentationDependencyOffTheRecord(map_ref, descriptor)); +#endif if (descriptors_field_type-&gt;IsClass()) { // Remember the field map, and try to infer a useful type. Handle&lt;Map&gt; map(descriptors_field_type-&gt;AsClass(), isolate()); @@ -384,15 +386,17 @@ PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo( } // TODO(turbofan): We may want to do this only depending on the use // of the access info. +#if 0 unrecorded_dependencies.push_back( dependencies()-&gt;FieldTypeDependencyOffTheRecord(map_ref, descriptor)); +#endif FieldType根据一些代码可以知道实际就是指代字段的map 这里将两个依赖注释了，导致当字段属性的representation为HeapObject时，程序没有正确地记录FieldOwner对于field的representation与type的依赖，而记录是通过对map install dependent code来完成的，因此在函数编译后，修改FieldOwner类型理论上也不会 所以理论上可以修改FieldOwner的类型来造成类型混淆 我们还需要确定一下函数的触发路径 在chromium code search中查找一下patch函数引用 只出现在ComputePropertyAccessInfo中，继续往下找 有两个引用 分别查看一下 GetPropertyAccessInfo用的更加频繁一些，同时注意到有一个ReduceNamedAccess，这表明turbofan在优化具名属性访问如o.xxx时会引用到这里的结果 剖析poc function opt(o) { return o.x.y; } let obj = {x: {y: 1.1}} for (let i = 0; i &lt; 100000; i++) opt(obj); obj.x = {z: {}}; console.log(opt(obj)) 观察生成的字节码 opt函数产生了两次属性访问 通过以下命令进行调试 gdb --args ./d8 --allow-natives-syntax --trace-opt-verbose --trace-deopt ./poc.js 通过turbolizer观察编译过程中的节点变化 发现产生了两个checkmaps，与我们预期的通过depend code进行deoptimize有些不符 且在loadelimination阶段将第二个checkmaps去除 分析checkmaps的出处 当receiver转换为string或number失败时调用BuildCheckMaps 调试发现m.HasValue()对于两次调用均不成立 发现此函数需要node的opcode为HeapConstant，难以满足，所以落入checkmaps的path 通过调试也发现dependent code集中在o.x而非o 分析loadelimination中发生的事 调用ReduceCheckMaps，第一次调用时，node state中没有记录map，通过该checkmaps后更新check的map范围到node state中 再经过ReduceLoadField获取到field的map，更新到node state中，故第二次时map会落入范围中，成功reduce poc中最后使用了重赋值来修改obj.x的类型，这个操作并不会改变obj的map 同时也注意到obj的初始化方式较为特别 let obj = {x: {y: 1.1}} v8中初始化对象时，若采取以下形式 let a = {b:1,c:2,d:3,e:4,f:5} 则v8会尽量优化成a对象中带有5个inline property，直接依附在对象结构上，而不在Properties数组中 同时一个字典默认初始化时，一般会带有4个默认的slot来存放property let a = {} a.x0 = 0; // inline a.x1 = 1; // inline a.x2 = 2; // inline a.x3 = 3; // inline a.x4 = 4; // in properties 具体可以参考v8 blogs中的这篇文章 同时触发混淆的成员名不能与原来相同 let obj = {x: {y: 1.1}} for (let i = 0; i &lt; 100000; i++) opt(obj); obj.x = {z: {}}; console.log(opt(obj)) 即此处的z不能为y 因为这样创造出来的{y:{}}实际是{y:1.1}的泛化 由于v8的field representation generalization机制，当一个field被修改成一个更加泛用的类型的值时，如smi修改为Tagged指针，为了表示这样的转变，v8根据版本不同会有两种处理方式，较早的版本会建立一个新map，将field representation修改为Tagged，将原来的map舍弃，较新的版本考虑到性能问题，会就地进行可兼容的representation转换，但是这两种方法最终都会invalidate code dependency，导致deoptimize 这个逻辑实现在Map::GeneralizeField中","headline":"2019 强网杯 accessible分析","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/v8/2023/08/28/accessible.html"},"url":"http://localhost:4000/v8/2023/08/28/accessible.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="ln3&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">ln3&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">2019 强网杯 accessible分析</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-08-28T07:20:22+08:00" itemprop="datePublished">Aug 28, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="分析patch">分析patch</h2>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/compiler/access-info.cc b/src/compiler/access-info.cc
index 0744138..1df06df 100644
</span><span class="gd">--- a/src/compiler/access-info.cc
</span><span class="gi">+++ b/src/compiler/access-info.cc
</span><span class="p">@@ -370,9 +370,11 @@</span> PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo(
       // The field type was cleared by the GC, so we don't know anything
       // about the contents now.
     }
<span class="gi">+#if 0
</span>     unrecorded_dependencies.push_back(
         dependencies()-&gt;FieldRepresentationDependencyOffTheRecord(map_ref,
                                                                   descriptor));
<span class="gi">+#endif
</span>     if (descriptors_field_type-&gt;IsClass()) {
       // Remember the field map, and try to infer a useful type.
       Handle&lt;Map&gt; map(descriptors_field_type-&gt;AsClass(), isolate());
<span class="p">@@ -384,15 +386,17 @@</span> PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo(
   }
   // TODO(turbofan): We may want to do this only depending on the use
   // of the access info.
<span class="gi">+#if 0
</span>   unrecorded_dependencies.push_back(
       dependencies()-&gt;FieldTypeDependencyOffTheRecord(map_ref, descriptor));
<span class="gi">+#endif
</span> 
   PropertyConstness constness;
   if (details.IsReadOnly() &amp;&amp; !details.IsConfigurable()) {
     constness = PropertyConstness::kConst;
   } else {
     map_ref.SerializeOwnDescriptor(descriptor);
<span class="gd">-    constness = dependencies()-&gt;DependOnFieldConstness(map_ref, descriptor);
</span><span class="gi">+    constness = PropertyConstness::kConst;
</span>   }
   Handle&lt;Map&gt; field_owner_map(map-&gt;FindFieldOwner(isolate(), descriptor),
                               isolate());
</code></pre></div></div>

<p>patch点位于ComputeDataFieldAccessInfo中</p>

<p>将两个unrecord_dependencies.push的操作注释掉了，同时将PropertyConstness类型的constness将原来的DependOnFieldConstness结果改为了固定的kConst</p>

<p>找到该函数的源码</p>

<p><img src="/imgs/image-20230602161311034.png" alt="image-20230602161311034" /></p>

<p>该函数返回了一个DataField或者DataConst，但是仅有一个kind不同</p>

<p><img src="/imgs/image-20230602161617639.png" alt="image-20230602161617639" /></p>

<p>同时也注意到第一个push出现在details_representation为HeapObject的case</p>

<p><img src="/imgs/image-20230602161358730.png" alt="image-20230602161358730" /></p>

<p>向上查看details_representation指代的对象是谁</p>

<p><img src="/imgs/image-20230602161733603.png" alt="image-20230602161733603" /></p>

<p>从details获取details_representation，details为map的DescriptorArray中的某一项属性记录的detail</p>

<p>receiver_map为被查找对象的map，向上寻找map变量的来源</p>

<p><img src="/imgs/image-20230603200121221.png" alt="image-20230603200121221" /></p>

<p>经过一些调试会发现此时的receiver_map与map均为被访问对象的map</p>

<p>此循环在原型链上搜索属性，以map为循环变量，传入的map为实际的拥有属性的对象的map，所以如果仅在变量上定义属性时这里一般会相等</p>

<p>分析一下被去掉的代码的作用</p>

<p><img src="/imgs/image-20230603201225324.png" alt="image-20230603201225324" /></p>

<p><img src="/imgs/image-20230603201236889.png" alt="image-20230603201236889" /></p>

<p>函数产生了一个CompilationDependency一个抽象基类指针</p>

<p>CompilationDependency派生出很多Dependency</p>

<p><img src="/imgs/image-20230603201449118.png" alt="image-20230603201449118" /></p>

<p><img src="/imgs/image-20230603201523083.png" alt="image-20230603201523083" /></p>

<p>都实现了Install函数，对code安装依赖</p>

<p>根据对jit编译的了解，可以知道这些dependency是用来标明jit代码的依赖，当依赖不满足时及时地将代码deoptimize回bytecode解释器执行</p>

<p><img src="/imgs/image-20230603201853383.png" alt="image-20230603201853383" /></p>

<p>在建立依赖的过程中，首先从拥有属性的map中调用FindFieldOwner</p>

<p>需要理解一下这个fieldowner具体是指谁的map</p>

<p><img src="/imgs/image-20230606144603524.png" alt="image-20230606144603524" /></p>

<p>实现中有两种实现，在jsheapbroker的模式为disable时调用map的FindFieldOwner方法</p>

<p>或者是从mapref类所引用的map的instance_descriptors中找到对应索引的PropertyDescriptor</p>

<p><img src="/imgs/image-20230606144808193.png" alt="image-20230606144808193" /></p>

<p>里面只有一个字段看起来是与map相关的，即field_owner</p>

<p>我们写一个例子来看一下</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">:{</span><span class="dl">'</span><span class="s1">q</span><span class="dl">'</span><span class="p">:</span><span class="mf">1.1</span><span class="p">}};</span>
<span class="o">%</span><span class="nx">DebugPrint</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>
<span class="o">%</span><span class="nx">DebugPrint</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">p</span><span class="p">);</span>
<span class="o">%</span><span class="nx">SystemBreak</span><span class="p">();</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DebugPrint: 0x273fe544b249: [JS_OBJECT_TYPE]
 - map: 0x11232970a6b9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
 - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt;
 - elements: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]
 - properties: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; {
    #p: 0x273fe544b269 &lt;Object map = 0x11232970a669&gt; (const data field 0)
 }
0x11232970a6b9: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 32
 - inobject properties: 1
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - stable_map
 - back pointer: 0x11232970a619 &lt;Map(HOLEY_ELEMENTS)&gt;
 - prototype_validity cell: 0x2a8e03680659 &lt;Cell value= 1&gt;
 - instance descriptors (own) #1: 0x273fe544b2b9 &lt;DescriptorArray[1]&gt;
 - layout descriptor: (nil)
 - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt;
 - constructor: 0x1b89284c2119 &lt;JSFunction Object (sfi = 0x2a8e036898e9)&gt;
 - dependent code: 0x1cf27a1c02a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;
 - construction counter: 0

DebugPrint: 0x273fe544b269: [JS_OBJECT_TYPE]
 - map: 0x11232970a669 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
 - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt;
 - elements: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]
 - properties: 0x1cf27a1c0c01 &lt;FixedArray[0]&gt; {
    #q: &lt;unboxed double&gt; 1.1 (const data field 0)
 }
0x11232970a669: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 32
 - inobject properties: 1
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - stable_map
 - back pointer: 0x11232970a619 &lt;Map(HOLEY_ELEMENTS)&gt;
 - prototype_validity cell: 0x2a8e03680659 &lt;Cell value= 1&gt;
 - instance descriptors (own) #1: 0x273fe544b289 &lt;DescriptorArray[1]&gt;
 - layout descriptor: 0x100000000
 - prototype: 0x1b89284c20e1 &lt;Object map = 0x112329700209&gt;
 - constructor: 0x1b89284c2119 &lt;JSFunction Object (sfi = 0x2a8e036898e9)&gt;
 - dependent code: 0x1cf27a1c02a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;
 - construction counter: 0

pwndbg&gt; job 0x273fe544b2b9
0x273fe544b2b9: [DescriptorArray]
 - map: 0x1cf27a1c0251 &lt;Map&gt;
 - enum_cache: empty
 - nof slack descriptors: 0
 - nof descriptors: 1
 - raw marked descriptors: mc epoch 0, marked 0
  [0]: #p (const data field 0:h, p: 0, attrs: [WEC]) @ Class(0x11232970a669)
pwndbg&gt; tel 0x273fe544b2b9-1
00:0000│  0x273fe544b2b8 —▸ 0x1cf27a1c0251 ◂— 0x1cf27a1c01
01:0008│  0x273fe544b2c0 ◂— 0x10001
02:0010│  0x273fe544b2c8 —▸ 0x1cf27a1c2389 ◂— 0x100001cf27a1c23
03:0018│  0x273fe544b2d0 —▸ 0x1b89284df859 ◂— 0x4200001cf27a1c04
04:0020│  0x273fe544b2d8 ◂— 0xc400000000
05:0028│  0x273fe544b2e0 —▸ 0x11232970a66b ◂— 0x4030400001cf27a # field map
06:0030│  0x273fe544b2e8 ◂— 0xdeadbeedbeadbeef
07:0038│  0x273fe544b2f0 ◂— 0xdeadbeedbeadbeef
pwndbg&gt; job 0x1b89284df859
#p
</code></pre></div></div>

<p>可以观察到o对象的instace_descriptor的DescriptorArray中拥有p的map</p>

<p>看似此时可以得到FindFieldOwner返回的应该是字段的map的结论，但是调试过后发现并非如此</p>

<p><img src="/imgs/image-20230606153859300.png" alt="image-20230606153859300" /></p>

<p>分析map的FindFieldOwner函数，理论上该函数应当与mapref中的函数返回相同结果</p>

<p>这里进行了一个循环，遍历对象的back pointer链来寻找一个拥有descriptor索引的instance_descriptor，并将具有这个instace_descriptor的对象作为map返回</p>

<p>但是我们这里的back pointer是不存在这个属性的</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; job 0xe2008c0a6b9
0xe2008c0a6b9: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 32
 - inobject properties: 1
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - stable_map
 - back pointer: 0x0e2008c0a619 &lt;Map(HOLEY_ELEMENTS)&gt;                 # back pointer链
 - prototype_validity cell: 0x0d2e9b9c0659 &lt;Cell value= 1&gt;
 - instance descriptors (own) #1: 0x31de10fcb5c1 &lt;DescriptorArray[1]&gt; # 长度 == 1, 需要找到一个有0索引的对象
 - layout descriptor: (nil)
 - prototype: 0x24c1d11820e1 &lt;Object map = 0xe2008c00209&gt;
 - constructor: 0x24c1d1182119 &lt;JSFunction Object (sfi = 0xd2e9b9c98e9)&gt;
 - dependent code: 0x02f667c402a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;
 - construction counter: 0
pwndbg&gt; job 0x0e2008c0a619
0xe2008c0a619: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 32
 - inobject properties: 1
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 1
 - enum length: invalid
 - back pointer: 0x02f667c404b1 &lt;undefined&gt;							   # 链尾
 - prototype_validity cell: 0x0d2e9b9c0659 &lt;Cell value= 1&gt;
 - instance descriptors (own) #0: 0x02f667c40239 &lt;DescriptorArray[0]&gt;  # 长度 == 0
 - layout descriptor: (nil)
 - transitions #2: 0x24c1d119fe11 &lt;TransitionArray[6]&gt;Transition array #2:
     #a: (transition to (const data field, attrs: [WEC]) @ Class(0xe2008c0a669)) -&gt; 0x0e2008c0a6b9 &lt;Map(HOLEY_ELEMENTS)&gt;
     #m: (transition to (const data field, attrs: [WEC]) @ Any) -&gt; 0x0e2008c0a669 &lt;Map(HOLEY_ELEMENTS)&gt;

 - prototype: 0x24c1d11820e1 &lt;Object map = 0xe2008c00209&gt;
 - constructor: 0x24c1d1182119 &lt;JSFunction Object (sfi = 0xd2e9b9c98e9)&gt;
 - dependent code: 0x02f667c402a1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;
 - construction counter: 0
</code></pre></div></div>

<p>所以这个函数最后返回的依然是本对象的map，而不是先前推测的字段属性的map，</p>

<p>而关于之前DescriptorArray中的map的来源，从chromium code search里DescriptorArray的注释中提到结构中的value可能会有一个map的weak reference，但是并没有解释其作用与具体指向</p>

<p><img src="/imgs/image-20230606160112227.png" alt="image-20230606160112227" /></p>

<p>我们可以以此推测jsheapbroker实际上会对js对象的一些数据做cache，将对象的字段的owner记录在PropertyDescriptor结构中，这样就省去了每次遍历back pointer的开销</p>

<p>查找一下引用会发现在SerializeOwnDescriptor中，存在对PropertyDescriptor的创建</p>

<p><img src="/imgs/image-20230606160605434.png" alt="image-20230606160605434" /></p>

<p>简要分析可以发现该函数透过jsheapbroker更新了map的instance_descriptor中对应属性的PropertyDescriptor信息，验证了我们刚才的推测</p>

<p><img src="/imgs/image-20230603201853383.png" alt="image-20230603201853383" /></p>

<p>回到函数，可以确认此时owner为拥有此属性的对象的map</p>

<p><img src="/imgs/image-20230606163637241.png" alt="image-20230606163637241" /></p>

<p><img src="/imgs/image-20230606163651195.png" alt="image-20230606163651195" /></p>

<p>InstallDependency的逻辑较为简单，更新将code插入map的dependent code字段数组中</p>

<p>我们看到PropertyAccessBuilder的BuildCheckMaps函数的逻辑</p>

<p><img src="/imgs/image-20230606162757037.png" alt="image-20230606162757037" /></p>

<p>可以看到这里有两种方式，第一种判断了receiver的map是否stable，如果stable，且根据access_info得到的receiver_maps中确实有这个map，则添加一个StableMap的依赖</p>

<p>否则创建一个checkmaps的node，在运行时鉴别对象的map</p>

<p>这里也说明了v8中有两种deoptimize的机制，一种是通过依赖来标记代码，在运行时若发生了依赖变化，则deoptimize相应代码，另一种则是使用checkmaps的代码来运行时检查map类型是否匹配</p>

<p>map的dependent code就是为了deoptimize而设，当map变为unstable时，即可根据该字段来遍历所有依赖当前stable map的optimized code</p>

<p><img src="/imgs/image-20230606164253443.png" alt="image-20230606164253443" /></p>

<p>所有依赖在Commit函数中被Install，时机为编译流水线的结尾</p>

<p><img src="/imgs/image-20230606185336157.png" alt="image-20230606185336157" /></p>

<p>此时审视我们最开始得到的patch</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+#if 0
</span>     unrecorded_dependencies.push_back(
         dependencies()-&gt;FieldRepresentationDependencyOffTheRecord(map_ref,
                                                                   descriptor));
<span class="gi">+#endif
</span>     if (descriptors_field_type-&gt;IsClass()) {
       // Remember the field map, and try to infer a useful type.
       Handle&lt;Map&gt; map(descriptors_field_type-&gt;AsClass(), isolate());
<span class="p">@@ -384,15 +386,17 @@</span> PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo(
   }
   // TODO(turbofan): We may want to do this only depending on the use
   // of the access info.
<span class="gi">+#if 0
</span>   unrecorded_dependencies.push_back(
       dependencies()-&gt;FieldTypeDependencyOffTheRecord(map_ref, descriptor));
<span class="gi">+#endif
</span></code></pre></div></div>

<p>FieldType根据一些代码可以知道实际就是指代字段的map</p>

<p>这里将两个依赖注释了，导致当字段属性的representation为HeapObject时，程序没有正确地记录FieldOwner对于field的representation与type的依赖，而记录是通过对map install dependent code来完成的，因此在函数编译后，修改FieldOwner类型理论上也不会</p>

<p>所以理论上可以修改FieldOwner的类型来造成类型混淆</p>

<p>我们还需要确定一下函数的触发路径</p>

<p>在chromium code search中查找一下patch函数引用</p>

<p><img src="/imgs/image-20230602155652981.png" alt="image-20230602155652981" /></p>

<p>只出现在ComputePropertyAccessInfo中，继续往下找</p>

<p><img src="/imgs/image-20230602155733376.png" alt="image-20230602155733376" /></p>

<p>有两个引用</p>

<p>分别查看一下</p>

<p><img src="/imgs/image-20230602155811751.png" alt="image-20230602155811751" /></p>

<p><img src="/imgs/image-20230602155915506.png" alt="image-20230602155915506" /></p>

<p>GetPropertyAccessInfo用的更加频繁一些，同时注意到有一个ReduceNamedAccess，这表明turbofan在优化具名属性访问如o.xxx时会引用到这里的结果</p>

<h2 id="剖析poc">剖析poc</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">opt</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="p">{</span><span class="na">y</span><span class="p">:</span> <span class="mf">1.1</span><span class="p">}}</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="nx">opt</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="p">{</span><span class="na">z</span><span class="p">:</span> <span class="p">{}};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">opt</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span>
</code></pre></div></div>

<p>观察生成的字节码</p>

<p><img src="/imgs/image-20230606194647224.png" alt="image-20230606194647224" /></p>

<p>opt函数产生了两次属性访问</p>

<p>通过以下命令进行调试</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb <span class="nt">--args</span> ./d8 <span class="nt">--allow-natives-syntax</span> <span class="nt">--trace-opt-verbose</span> <span class="nt">--trace-deopt</span> ./poc.js
</code></pre></div></div>

<p>通过turbolizer观察编译过程中的节点变化</p>

<p><img src="/imgs/image-20230606194908037.png" alt="image-20230606194908037" /></p>

<p><img src="/imgs/image-20230606194304500.png" alt="image-20230606194304500" /></p>

<p>发现产生了两个checkmaps，与我们预期的通过depend code进行deoptimize有些不符</p>

<p>且在loadelimination阶段将第二个checkmaps去除</p>

<p>分析checkmaps的出处</p>

<p><img src="/imgs/image-20230602160843157.png" alt="image-20230602160843157" /></p>

<p><img src="/imgs/image-20230606194447428.png" alt="image-20230606194447428" /></p>

<p>当receiver转换为string或number失败时调用BuildCheckMaps</p>

<p><img src="/imgs/image-20230606194513633.png" alt="image-20230606194513633" /></p>

<p>调试发现m.HasValue()对于两次调用均不成立</p>

<p><img src="/imgs/image-20230606195204624.png" alt="image-20230606195204624" /></p>

<p><img src="/imgs/image-20230606195247896.png" alt="image-20230606195247896" /></p>

<p>发现此函数需要node的opcode为HeapConstant，难以满足，所以落入checkmaps的path</p>

<p>通过调试也发现dependent code集中在o.x而非o</p>

<p><img src="/imgs/image-20230606203223136.png" alt="image-20230606203223136" /></p>

<p>分析loadelimination中发生的事</p>

<p><img src="/imgs/image-20230606203403032.png" alt="image-20230606203403032" /></p>

<p>调用ReduceCheckMaps，第一次调用时，node state中没有记录map，通过该checkmaps后更新check的map范围到node state中</p>

<p>再经过ReduceLoadField获取到field的map，更新到node state中，故第二次时map会落入范围中，成功reduce</p>

<p>poc中最后使用了重赋值来修改obj.x的类型，这个操作并不会改变obj的map</p>

<p>同时也注意到obj的初始化方式较为特别</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="p">{</span><span class="na">y</span><span class="p">:</span> <span class="mf">1.1</span><span class="p">}}</span>
</code></pre></div></div>

<p>v8中初始化对象时，若采取以下形式</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span><span class="na">b</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="na">c</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="na">d</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="na">e</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="na">f</span><span class="p">:</span><span class="mi">5</span><span class="p">}</span>
</code></pre></div></div>

<p>则v8会尽量优化成a对象中带有5个inline property，直接依附在对象结构上，而不在Properties数组中</p>

<p>同时一个字典默认初始化时，一般会带有4个默认的slot来存放property</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{}</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">x0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// inline</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">x1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// inline</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">x2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// inline</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">x3</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// inline</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">x4</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// in properties</span>
</code></pre></div></div>

<p>具体可以参考v8 blogs中的<a href="https://v8.dev/blog/fast-properties">这篇文章</a></p>

<p>同时触发混淆的成员名不能与原来相同</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="p">{</span><span class="na">y</span><span class="p">:</span> <span class="mf">1.1</span><span class="p">}}</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="nx">opt</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="p">{</span><span class="na">z</span><span class="p">:</span> <span class="p">{}};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">opt</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span>
</code></pre></div></div>

<p>即此处的z不能为y</p>

<p>因为这样创造出来的{y:{}}实际是{y:1.1}的泛化</p>

<p>由于v8的field representation generalization机制，当一个field被修改成一个更加泛用的类型的值时，如smi修改为Tagged指针，为了表示这样的转变，v8根据版本不同会有两种处理方式，较早的版本会建立一个新map，将field representation修改为Tagged，将原来的map舍弃，较新的版本考虑到性能问题，会就地进行可兼容的representation转换，但是这两种方法最终都会invalidate code dependency，导致deoptimize</p>

<p>这个逻辑实现在Map::GeneralizeField中</p>

<p><img src="/imgs/image-20230613214250869.png" alt="image-20230613214250869" /></p>


  </div><a class="u-url" href="/v8/2023/08/28/accessible.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">ln3&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">ln3&#39;s blog</li><li><a class="u-email" href="mailto:1816154@gmail.com">1816154@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/golbeze"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">golbeze</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>binary noob
</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
